%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{0}



\title{pusion Documentation}
\date{Dec 13, 2022}
\release{}
\author{Admir Obralija, Yannick Wilhelm}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
Pusion (Python Universal Fusion) is a flexible framework for combining multi\sphinxhyphen{}classifier decisions in Python.

\sphinxAtStartPar
The framework accommodates a variety of fusion methods adapted from ensemble techniques and pattern recognition.
The general purpose is to improve the classification performance over the input classifiers and to determine the
compatibility of individual fusion methods to the given problem.
Pusion handles an unlimited number of classifiers and also tolerates different forms of classification outputs.
This includes the multiclass and multilabel classification, as well as crisp and continuous class assignments.

\sphinxAtStartPar
The framework is originally designed for combining fault detection and diagnosis methods.
However, its application is not limited to this area.

\sphinxAtStartPar
This documentation includes the following sections:


\chapter{Overview}
\label{\detokenize{overview:overview}}\label{\detokenize{overview::doc}}

\section{Introduction}
\label{\detokenize{overview:introduction}}
\sphinxAtStartPar
In general, there exist two main approaches to combine multiple classifiers in order to obtain reasonable classification
outputs for unseen samples: the classifier selection and the classifier fusion.
The latter one is followed by the presented framework and illustrated in \hyperref[\detokenize{overview:fig-context}]{Fig.\@ \ref{\detokenize{overview:fig-context}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{framework_context}.pdf}
\caption{Architectural embedding of the decision fusion framework}\label{\detokenize{overview:id1}}\label{\detokenize{overview:fig-context}}\end{figure}

\sphinxAtStartPar
However, there are significant properties arising from such classifier ensembles as parameters which need to be
considered in the whole decision fusion process.
These parameters are forming a configuration which consists of:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Decision fusion method (\sphinxtitleref{combiner})

\item {} 
\sphinxAtStartPar
Classification problem

\item {} 
\sphinxAtStartPar
Class assignment type

\item {} 
\sphinxAtStartPar
Classification coverage

\end{itemize}

\sphinxAtStartPar
The \sphinxtitleref{combiner} states an explicit method provided by the framework which should be applied on the input data set.
Available core methods are listed in the following section.

\sphinxAtStartPar
The \sphinxtitleref{classification problem} refers either to a multiclass or to a multilabel classification problem.
In the multiclass case, a sample is always classified into one class, while in the multilabel case, more than one class
may be assigned to a sample.

\sphinxAtStartPar
Pusion operates on classification data which is given by class assignments.
The class assignment describes memberships to each individual class for a sample.
A \sphinxtitleref{class assignment type} is either crisp or continuous. Crisp assignments are equivalent to labels
and continuous assignments represent probabilities for each class being true.

\sphinxAtStartPar
The \sphinxtitleref{classification coverage} states for each input classifier, which classes it is able to decide.
A classifier ensemble may yield a redundant, complementary or complementary\sphinxhyphen{}redundant coverage.


\section{Core methods}
\label{\detokenize{overview:core-methods}}
\sphinxAtStartPar
The following core decision fusion methods are supported by \sphinxtitleref{pusion} and classified according to the evidence resolution
they accept. With lower evidence resolution, a weaker a\sphinxhyphen{}priori information about individual classifiers can be taken
into account during the fusion process.
Utility\sphinxhyphen{}based methods do not take any further information about classifiers into account.
In cases where no evidence is available for a certain classification data set, a utility\sphinxhyphen{}based method is a reasonable
choice.
Evidence\sphinxhyphen{}based methods are recommended in cases where evidence (e.g. confusion matrices) but no training data is
available for each classifier.
Trainable methods provide the highest evidence resolution, since decision outputs are required from the ensemble for
each sample during the training phase.
Therefore, each \sphinxtitleref{trainable combiner} is able to calculate any kind of evidence based on the training data and is even
able to analyse the behaviour of each classification method from the ensemble.

\sphinxAtStartPar
Utility\sphinxhyphen{}based methods (low evidence resolution):
\begin{itemize}
\item {} 
\sphinxAtStartPar
Borda Count ({\hyperref[\detokenize{pusion.core.borda_count_combiner:bc-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{BC}}}})

\item {} 
\sphinxAtStartPar
Cosine Similarity ({\hyperref[\detokenize{pusion.core.cosine_similarity_combiner:cos-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{COS}}}})

\item {} 
\sphinxAtStartPar
Macro Majority Vote ({\hyperref[\detokenize{pusion.core.macro_majority_vote_combiner:mamv-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{MAMV}}}})

\item {} 
\sphinxAtStartPar
Micro Majority Vote ({\hyperref[\detokenize{pusion.core.micro_majority_vote_combiner:mimv-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{MIMV}}}})

\item {} 
\sphinxAtStartPar
Simple Average ({\hyperref[\detokenize{pusion.core.simple_average_combiner:avg-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{AVG}}}})

\end{itemize}

\sphinxAtStartPar
Evidence\sphinxhyphen{}based methods (medium evidence resolution):
\begin{itemize}
\item {} 
\sphinxAtStartPar
Naive Bayes ({\hyperref[\detokenize{pusion.core.naive_bayes_combiner:nb-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{NB}}}})

\item {} 
\sphinxAtStartPar
Weighted Voting ({\hyperref[\detokenize{pusion.core.weighted_voting_combiner:wv-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{WV}}}})

\end{itemize}

\sphinxAtStartPar
Trainable methods (highest evidence resolution):
\begin{itemize}
\item {} 
\sphinxAtStartPar
Behaviour Knowledge Space ({\hyperref[\detokenize{pusion.core.behaviour_knowledge_space_combiner:bks-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{BKS}}}})

\item {} 
\sphinxAtStartPar
Decision Templates ({\hyperref[\detokenize{pusion.core.decision_templates_combiner:dt-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{DT}}}})

\item {} 
\sphinxAtStartPar
k Nearest Neighbors ({\hyperref[\detokenize{pusion.core.k_nearest_neighbors_combiner:knn-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{KNN}}}})

\item {} 
\sphinxAtStartPar
Dempster Shafer ({\hyperref[\detokenize{pusion.core.dempster_shafer_combiner:ds-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{DS}}}})

\item {} 
\sphinxAtStartPar
Maximum Likelihood ({\hyperref[\detokenize{pusion.core.maximum_likelihood_combiner:mle-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{MLE}}}})

\item {} 
\sphinxAtStartPar
Neural Network ({\hyperref[\detokenize{pusion.core.neural_network_combiner:nn-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{NN}}}})

\end{itemize}


\section{Data input and output}
\label{\detokenize{overview:data-input-and-output}}
\sphinxAtStartPar
The input type used for classification data is generic and applies to all provided decision fusion methods.
It is given by a 3D \sphinxhref{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html}{numpy.ndarray} tensor,
which is illustrated in \hyperref[\detokenize{overview:fig-input-tensor-illustration}]{Fig.\@ \ref{\detokenize{overview:fig-input-tensor-illustration}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{input_tensor_illustration}.svg}
\caption{Illustration of the input tensor for a multilabel problem with crisp assignments
(3 samples, 4 classes, 2 classifiers).}\label{\detokenize{overview:id2}}\label{\detokenize{overview:fig-input-tensor-illustration}}\end{figure}

\sphinxAtStartPar
The same applies also to the pusion’s return, except that the output matrix is a 2D \sphinxtitleref{numpy.ndarray}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In case of complementary\sphinxhyphen{}redundant decisions, the coverage needs to be specified besides ordinary python lists,
which are used as an alternative to the \sphinxtitleref{numpy.ndarray}.
\end{sphinxadmonition}


\section{AutoFusion}
\label{\detokenize{overview:autofusion}}
\sphinxAtStartPar
The framework provides an additional fusion method {\hyperref[\detokenize{pusion.auto.auto_combiner:ac-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{AutoCombiner}}}} which is able to the detect the configuration
based on the input classification data and to automatically select the fusion method with the best classification
performance for the given problem.
The \sphinxtitleref{AutoCombiner} bundles all methods provided by the framework and probes each of them for the application on the
given classification data.
The \sphinxtitleref{AutoCombiner} is transparent to the user as each of the core fusion methods.


\section{Generic fusion}
\label{\detokenize{overview:generic-fusion}}
\sphinxAtStartPar
In contrast to the \sphinxtitleref{AutoCombiner}, the {\hyperref[\detokenize{pusion.auto.generic_combiner:gc-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{GenericCombiner}}}} retrieves fusion results obtained by all
compatible core methods by means of a \sphinxtitleref{numpy.ndarray} tensor. In this case, the evaluation as well as the method
selection is handed over to the user.


\section{Further functionalities}
\label{\detokenize{overview:further-functionalities}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Classification data and coverage generation (see module {\hyperref[\detokenize{pusion.util.generator:generator-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{generator}}}})

\item {} 
\sphinxAtStartPar
Useful transformations for decision outputs, e.g. multilabel to multiclass conversion
(see module {\hyperref[\detokenize{pusion.util.transformer:transformer-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{transformer}}}})

\item {} 
\sphinxAtStartPar
Evaluation methods for different classification and coverage types (see class {\hyperref[\detokenize{pusion.evaluation.evaluation:eval-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{Evaluation}}}})

\end{itemize}


\chapter{Install Pusion}
\label{\detokenize{install:install-pusion}}\label{\detokenize{install::doc}}

\section{General requirements}
\label{\detokenize{install:general-requirements}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Python \textgreater{}= 3.6

\end{itemize}


\section{Package requirements}
\label{\detokenize{install:package-requirements}}\begin{itemize}
\item {} 
\sphinxAtStartPar
numpy \textgreater{}= 1.20.2

\item {} 
\sphinxAtStartPar
scipy \textgreater{}= 1.6.2

\item {} 
\sphinxAtStartPar
scikit\sphinxhyphen{}learn \textgreater{}= 0.24.1

\item {} 
\sphinxAtStartPar
setuptools \textgreater{}= 54.2.0

\item {} 
\sphinxAtStartPar
pandas \textgreater{}= 1.2.3

\item {} 
\sphinxAtStartPar
matplotlib \textgreater{}= 3.4.1

\end{itemize}


\section{Preparation}
\label{\detokenize{install:preparation}}
\sphinxAtStartPar
To generate the python distribution archives of \sphinxtitleref{pusion}, update the PyPA’s build to the latest version. Under \sphinxtitleref{Windows} run in your python environment the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
py \PYGZhy{}m pip install \PYGZhy{}\PYGZhy{}upgrade build
\end{sphinxVerbatim}

\sphinxAtStartPar
If you are using \sphinxtitleref{MacOS} or \sphinxtitleref{Unix}, run in your python environment:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m pip install \PYGZhy{}\PYGZhy{}upgrade build
\end{sphinxVerbatim}

\sphinxAtStartPar
After cloning \sphinxtitleref{pusion} from GitHub to your local computer, enter the \sphinxtitleref{pusion} directory where the file \sphinxtitleref{pyproject.toml} is located. Under this directory run the following \sphinxtitleref{build} command. For \sphinxtitleref{Windows} users:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
py \PYGZhy{}m build
\end{sphinxVerbatim}

\sphinxAtStartPar
For \sphinxtitleref{MacOS} or \sphinxtitleref{Unix} user:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m build
\end{sphinxVerbatim}

\sphinxAtStartPar
Once successfully executed, two files are generated in the \sphinxtitleref{dist} subfolder within the project’s root folder. The \sphinxtitleref{tar.gz} file is the source distribution and the \sphinxtitleref{whl} file is the built distribution.


\section{Installation}
\label{\detokenize{install:installation}}
\sphinxAtStartPar
The generated wheel can be installed using the \sphinxcode{\sphinxupquote{pip3}} command, which also installs all required packages for \sphinxtitleref{pusion}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3 install dist/pusion\PYGZhy{}\PYGZlt{}version\PYGZgt{}\PYGZhy{}py3\PYGZhy{}none\PYGZhy{}any.whl
\end{sphinxVerbatim}


\chapter{API Reference}
\label{\detokenize{pusion:api-reference}}\label{\detokenize{pusion::doc}}

\section{pusion.auto package}
\label{\detokenize{pusion.auto:pusion-auto-package}}\label{\detokenize{pusion.auto::doc}}

\subsection{pusion.auto.auto\_combiner}
\label{\detokenize{pusion.auto.auto_combiner:module-pusion.auto.auto_combiner}}\label{\detokenize{pusion.auto.auto_combiner:pusion-auto-auto-combiner}}\label{\detokenize{pusion.auto.auto_combiner:ac-cref}}\label{\detokenize{pusion.auto.auto_combiner::doc}}\index{module@\spxentry{module}!pusion.auto.auto\_combiner@\spxentry{pusion.auto.auto\_combiner}}\index{pusion.auto.auto\_combiner@\spxentry{pusion.auto.auto\_combiner}!module@\spxentry{module}}\index{AutoCombiner (class in pusion.auto.auto\_combiner)@\spxentry{AutoCombiner}\spxextra{class in pusion.auto.auto\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.auto.auto\_combiner.}}\sphinxbfcode{\sphinxupquote{AutoCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.auto.generic\_combiner.GenericCombiner}}}}}

\sphinxAtStartPar
The \sphinxtitleref{AutoCombiner} allows for automatic decision fusion using all methods provided by the framework, which are
applicable to the given problem. The key feature of this combiner is the transparency in terms of it’s outer
behaviour. Based on the usage (i.e. method calls) and the automatically detected configuration,
the \sphinxtitleref{AutoCombiner} preselects all compatible methods from \sphinxtitleref{pusion.core}. The main purpose is to retrieve fusion
results obtained by the methods with the best performance without further user interaction.
\index{train() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{train()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Train the AutoCombiner (AC) model. This method detects the configuration based on the \sphinxcode{\sphinxupquote{decision\_tensor}} and
trains all trainable combiners that are applicable to this configuration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{combine()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs using the AutoCombiner (AC) model. Both continuous and crisp classification outputs are
supported. This procedure involves selecting the best method regarding its classification performance in case
of a trained AC.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp or continuous class assignments which represents fused decisions.
Axis 0 represents samples and axis 1 the class labels which are aligned with axis 2 in
\sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_validation\_size() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{set\_validation\_size()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.set_validation_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_validation\_size}}}{\emph{\DUrole{n}{validation\_size}}}{}
\sphinxAtStartPar
Set the validation size, based on which the training data is split and the best combiner is selected.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{validation\_size}} \textendash{} A \sphinxtitleref{float} between \sphinxtitleref{0} and \sphinxtitleref{1.0}. Ratio of the validation data set.

\end{description}\end{quote}

\end{fulllineitems}

\index{combine\_par() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{combine\_par()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.combine_par}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine\_par}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by GC. Both continuous and crisp classification outputs are supported.
This procedure involves combining decision outputs by each individual method which is applicable
to the detected configuration. Each combine procedure is spawned in a separate thread and thus performed
in parallel.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classifiers)}.
Fusion results obtained by selected fusion methods.
The list is aligned with the list of preselected fusion methods (retrievable by \sphinxcode{\sphinxupquote{get\_combiners()}}).

\end{description}\end{quote}

\end{fulllineitems}

\index{combine\_seq() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{combine\_seq()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.combine_seq}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine\_seq}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by GC. Both continuous and crisp classification outputs are supported.
This procedure involves combining decision outputs by each individual method which is applicable
to the detected configuration. Each combine procedure is initiated in sequence.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classifiers)}.
Fusion results obtained by selected fusion methods.
The list is aligned with the list of preselected fusion methods (retrievable by \sphinxcode{\sphinxupquote{get\_combiners()}}).

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_combiner\_type\_selection() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{get\_combiner\_type\_selection()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.get_combiner_type_selection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_combiner\_type\_selection}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of combiner types established by usage.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_combiners() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{get\_combiners()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.get_combiners}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_combiners}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of core methods preselected by the \sphinxtitleref{AutoCombiner}.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_multi\_combiner\_decision\_tensor() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{get\_multi\_combiner\_decision\_tensor()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.get_multi_combiner_decision_tensor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_multi\_combiner\_decision\_tensor}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classifiers)}.
Fusion results obtained by selected fusion methods.
The list is aligned with the list of preselected fusion methods (retrievable by \sphinxcode{\sphinxupquote{get\_combiners()}}).

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_multi\_combiner\_runtimes() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{get\_multi\_combiner\_runtimes()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.get_multi_combiner_runtimes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_multi\_combiner\_runtimes}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
A \sphinxtitleref{tuple} of two lists of tuples describing the train and combine runtimes respectively.
Each inner tuple key value indexes the list of preselected fusion methods
(retrievable by \sphinxcode{\sphinxupquote{get\_combiners()}}).

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_pac() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{get\_pac()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.get_pac}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_pac}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{tuple} of detected problem, assignment type and coverage type.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_selected\_combiner() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{get\_selected\_combiner()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.get_selected_combiner}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_selected\_combiner}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
The method selected by the \sphinxtitleref{AutoCombiner}.

\end{description}\end{quote}

\end{fulllineitems}

\index{obtain() (pusion.auto.auto\_combiner.AutoCombiner class method)@\spxentry{obtain()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.obtain}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{obtain}}}{\emph{\DUrole{n}{config}}}{}
\sphinxAtStartPar
Obtain a combiner registered by the framework.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{config}} \textendash{} {\hyperref[\detokenize{pusion.model.configuration:pusion.model.configuration.Configuration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.model.configuration.Configuration}}}}}. User\sphinxhyphen{}defined configuration.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A \sphinxtitleref{combiner} object.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_coverage() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{set\_coverage()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.set_coverage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_coverage}}}{\emph{\DUrole{n}{coverage}}}{}
\sphinxAtStartPar
Set the coverage in case of complementary\sphinxhyphen{}redundant classification data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} The coverage is described by using a nested list. Each list describes the classifier based on
its position. Elements of those lists (integers) describe the actual class coverage of the respective
classifier. E.g., with \sphinxcode{\sphinxupquote{{[}{[}0,1{]}, {[}0,2,3{]}{]}}} the classes 0,1 are covered by the first classifier and
0,2,3 are covered by the second one.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_evidence() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{set\_evidence()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.set_evidence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_evidence}}}{\emph{\DUrole{n}{evidence}}}{}
\sphinxAtStartPar
Set the evidence for evidence based combiners. This method preselects all combiners of type
\sphinxtitleref{EvidenceBasedCombiner}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{evidence}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_classes, n\_classes)}.
Confusion matrices for each of \sphinxtitleref{n} classifiers.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_parallel() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{set\_parallel()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.set_parallel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_parallel}}}{\emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Set whether the training and the combining of selected combiners should be executed sequentially or in parallel.
:param parallel: If \sphinxtitleref{True}, training and combining is performed in parallel respectively. Otherwise in sequence.

\end{fulllineitems}

\index{train\_par() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{train\_par()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.train_par}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train\_par}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Generic Combiner by training individual combiners in parallel.
This method detects the configuration based on the \sphinxcode{\sphinxupquote{decision\_tensor}} and trains all trainable combiners
that are applicable to this configuration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{train\_seq() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{train\_seq()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.train_seq}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train\_seq}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Generic Combiner by training individual combiners in sequence.
This method detects the configuration based on the \sphinxcode{\sphinxupquote{decision\_tensor}} and trains all trainable combiners
that are applicable to this configuration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_eval\_metric() (pusion.auto.auto\_combiner.AutoCombiner method)@\spxentry{get\_eval\_metric()}\spxextra{pusion.auto.auto\_combiner.AutoCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.auto_combiner:pusion.auto.auto_combiner.AutoCombiner.get_eval_metric}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_eval\_metric}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
The metric used for the selection of the best performing combiner.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.auto.generic\_combiner}
\label{\detokenize{pusion.auto.generic_combiner:module-pusion.auto.generic_combiner}}\label{\detokenize{pusion.auto.generic_combiner:pusion-auto-generic-combiner}}\label{\detokenize{pusion.auto.generic_combiner:gc-cref}}\label{\detokenize{pusion.auto.generic_combiner::doc}}\index{module@\spxentry{module}!pusion.auto.generic\_combiner@\spxentry{pusion.auto.generic\_combiner}}\index{pusion.auto.generic\_combiner@\spxentry{pusion.auto.generic\_combiner}!module@\spxentry{module}}\index{GenericCombiner (class in pusion.auto.generic\_combiner)@\spxentry{GenericCombiner}\spxextra{class in pusion.auto.generic\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.auto.generic\_combiner.}}\sphinxbfcode{\sphinxupquote{GenericCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.TrainableCombiner}}}}}, {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.EvidenceBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.EvidenceBasedCombiner}}}}}, {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.UtilityBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.UtilityBasedCombiner}}}}}

\sphinxAtStartPar
The \sphinxtitleref{GenericCombiner} (GC) allows for automatic decision fusion using all methods provided by the framework, which
are applicable to the given problem. The key feature of this combiner is the transparency in terms of it’s outer
behaviour. Based on the usage (i.e. method calls) and the automatically detected configuration,
the \sphinxtitleref{GenericCombiner} preselects all compatible methods from \sphinxtitleref{pusion.core}. The main purpose is to retrieve fusion
results obtained by the all applicable methods. The main difference to the \sphinxtitleref{AutoCombiner} is that decision fusion
results are handed over to the user for further comparison and selection. Thus, GC is not suitable for
the online fusion.
\index{set\_coverage() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{set\_coverage()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.set_coverage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_coverage}}}{\emph{\DUrole{n}{coverage}}}{}
\sphinxAtStartPar
Set the coverage in case of complementary\sphinxhyphen{}redundant classification data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} The coverage is described by using a nested list. Each list describes the classifier based on
its position. Elements of those lists (integers) describe the actual class coverage of the respective
classifier. E.g., with \sphinxcode{\sphinxupquote{{[}{[}0,1{]}, {[}0,2,3{]}{]}}} the classes 0,1 are covered by the first classifier and
0,2,3 are covered by the second one.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_evidence() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{set\_evidence()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.set_evidence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_evidence}}}{\emph{\DUrole{n}{evidence}}}{}
\sphinxAtStartPar
Set the evidence for evidence based combiners. This method preselects all combiners of type
\sphinxtitleref{EvidenceBasedCombiner}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{evidence}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_classes, n\_classes)}.
Confusion matrices for each of \sphinxtitleref{n} classifiers.

\end{description}\end{quote}

\end{fulllineitems}

\index{train() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{train()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Generic Combiner. This method detects the configuration based on the \sphinxcode{\sphinxupquote{decision\_tensor}} and
trains all trainable combiners that are applicable to this configuration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{train\_par() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{train\_par()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.train_par}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train\_par}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Generic Combiner by training individual combiners in parallel.
This method detects the configuration based on the \sphinxcode{\sphinxupquote{decision\_tensor}} and trains all trainable combiners
that are applicable to this configuration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{train\_seq() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{train\_seq()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.train_seq}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train\_seq}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Generic Combiner by training individual combiners in sequence.
This method detects the configuration based on the \sphinxcode{\sphinxupquote{decision\_tensor}} and trains all trainable combiners
that are applicable to this configuration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{combine()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs using the AutoCombiner (AC) model. Both continuous and crisp classification outputs are
supported. This procedure involves combining decision outputs by each individual method which is applicable
to the detected configuration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classifiers)}.
Fusion results obtained by selected fusion methods.
The list is aligned with the list of preselected fusion methods (retrievable by \sphinxcode{\sphinxupquote{get\_combiners()}}).

\end{description}\end{quote}

\end{fulllineitems}

\index{combine\_par() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{combine\_par()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.combine_par}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine\_par}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by GC. Both continuous and crisp classification outputs are supported.
This procedure involves combining decision outputs by each individual method which is applicable
to the detected configuration. Each combine procedure is spawned in a separate thread and thus performed
in parallel.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classifiers)}.
Fusion results obtained by selected fusion methods.
The list is aligned with the list of preselected fusion methods (retrievable by \sphinxcode{\sphinxupquote{get\_combiners()}}).

\end{description}\end{quote}

\end{fulllineitems}

\index{combine\_seq() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{combine\_seq()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.combine_seq}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine\_seq}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by GC. Both continuous and crisp classification outputs are supported.
This procedure involves combining decision outputs by each individual method which is applicable
to the detected configuration. Each combine procedure is initiated in sequence.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classifiers)}.
Fusion results obtained by selected fusion methods.
The list is aligned with the list of preselected fusion methods (retrievable by \sphinxcode{\sphinxupquote{get\_combiners()}}).

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_pac() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{get\_pac()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.get_pac}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_pac}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{tuple} of detected problem, assignment type and coverage type.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_combiners() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{get\_combiners()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.get_combiners}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_combiners}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of core methods preselected by the \sphinxtitleref{AutoCombiner}.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_combiner\_type\_selection() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{get\_combiner\_type\_selection()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.get_combiner_type_selection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_combiner\_type\_selection}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of combiner types established by usage.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_multi\_combiner\_decision\_tensor() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{get\_multi\_combiner\_decision\_tensor()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.get_multi_combiner_decision_tensor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_multi\_combiner\_decision\_tensor}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classifiers)}.
Fusion results obtained by selected fusion methods.
The list is aligned with the list of preselected fusion methods (retrievable by \sphinxcode{\sphinxupquote{get\_combiners()}}).

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_multi\_combiner\_runtimes() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{get\_multi\_combiner\_runtimes()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.get_multi_combiner_runtimes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_multi\_combiner\_runtimes}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
A \sphinxtitleref{tuple} of two lists of tuples describing the train and combine runtimes respectively.
Each inner tuple key value indexes the list of preselected fusion methods
(retrievable by \sphinxcode{\sphinxupquote{get\_combiners()}}).

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_parallel() (pusion.auto.generic\_combiner.GenericCombiner method)@\spxentry{set\_parallel()}\spxextra{pusion.auto.generic\_combiner.GenericCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.generic_combiner:pusion.auto.generic_combiner.GenericCombiner.set_parallel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_parallel}}}{\emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Set whether the training and the combining of selected combiners should be executed sequentially or in parallel.
:param parallel: If \sphinxtitleref{True}, training and combining is performed in parallel respectively. Otherwise in sequence.

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.auto.detector module}
\label{\detokenize{pusion.auto.detector:module-pusion.auto.detector}}\label{\detokenize{pusion.auto.detector:pusion-auto-detector-module}}\label{\detokenize{pusion.auto.detector::doc}}\index{module@\spxentry{module}!pusion.auto.detector@\spxentry{pusion.auto.detector}}\index{pusion.auto.detector@\spxentry{pusion.auto.detector}!module@\spxentry{module}}\index{determine\_problem() (in module pusion.auto.detector)@\spxentry{determine\_problem()}\spxextra{in module pusion.auto.detector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.detector:pusion.auto.detector.determine_problem}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.auto.detector.}}\sphinxbfcode{\sphinxupquote{determine\_problem}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Determine the classification problem based on the decision outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{string} constant \sphinxtitleref{‘MULTI\_CLASS’} or \sphinxtitleref{‘MULTI\_LABEL’}. See \sphinxtitleref{pusion.util.constants.Problem}.

\end{description}\end{quote}

\end{fulllineitems}

\index{determine\_assignment\_type() (in module pusion.auto.detector)@\spxentry{determine\_assignment\_type()}\spxextra{in module pusion.auto.detector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.detector:pusion.auto.detector.determine_assignment_type}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.auto.detector.}}\sphinxbfcode{\sphinxupquote{determine\_assignment\_type}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Determine the assignment type based on the decision outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{string} constant \sphinxtitleref{‘CRISP’} or \sphinxtitleref{‘CONTINUOUS’}. See \sphinxtitleref{pusion.util.constants.AssignmentType}.

\end{description}\end{quote}

\end{fulllineitems}

\index{determine\_coverage\_type() (in module pusion.auto.detector)@\spxentry{determine\_coverage\_type()}\spxextra{in module pusion.auto.detector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.detector:pusion.auto.detector.determine_coverage_type}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.auto.detector.}}\sphinxbfcode{\sphinxupquote{determine\_coverage\_type}}}{\emph{\DUrole{n}{coverage}}}{}
\sphinxAtStartPar
Determine the coverage type.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{list} elements. Each inner list contains classes as integers covered by a classifier,
which is identified by the positional index of the respective list.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{string} constant \sphinxtitleref{‘REDUNDANT’}, \sphinxtitleref{‘COMPLEMENTARY’}  or \sphinxtitleref{‘COMPLEMENTARY\_REDUNDANT’}.
See \sphinxtitleref{pusion.util.constants.CoverageType}.

\end{description}\end{quote}

\end{fulllineitems}

\index{determine\_pac() (in module pusion.auto.detector)@\spxentry{determine\_pac()}\spxextra{in module pusion.auto.detector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.auto.detector:pusion.auto.detector.determine_pac}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.auto.detector.}}\sphinxbfcode{\sphinxupquote{determine\_pac}}}{\emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{coverage}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Determine the PAC\sphinxhyphen{}tuple (problem, assignment type and coverage type) based on the given decision outputs and
coverage.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{list} elements. Each inner list contains classes as integers covered by a classifier,
which is identified by the positional index of the respective list.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{tuple} of string constants representing the PAC. See \sphinxtitleref{pusion.util.constants.Problem},
\sphinxtitleref{pusion.util.constants.AssignmentType} and \sphinxtitleref{pusion.util.constants.CoverageType}.

\end{description}\end{quote}

\end{fulllineitems}



\section{pusion.control package}
\label{\detokenize{pusion.control:pusion-control-package}}\label{\detokenize{pusion.control::doc}}

\subsection{pusion.control.decision\_processor module}
\label{\detokenize{pusion.control.decision_processor:module-pusion.control.decision_processor}}\label{\detokenize{pusion.control.decision_processor:pusion-control-decision-processor-module}}\label{\detokenize{pusion.control.decision_processor::doc}}\index{module@\spxentry{module}!pusion.control.decision\_processor@\spxentry{pusion.control.decision\_processor}}\index{pusion.control.decision\_processor@\spxentry{pusion.control.decision\_processor}!module@\spxentry{module}}\index{DecisionProcessor (class in pusion.control.decision\_processor)@\spxentry{DecisionProcessor}\spxextra{class in pusion.control.decision\_processor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.control.decision\_processor.}}\sphinxbfcode{\sphinxupquote{DecisionProcessor}}}{\emph{\DUrole{n}{config}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{pusion.model.configuration:pusion.model.configuration.Configuration}]{\sphinxcrossref{pusion.model.configuration.Configuration}}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
{\hyperref[\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DecisionProcessor}}}}} is the main user interface of the decision fusion framework. It provides all methods
for selecting combiners including the {\hyperref[\detokenize{pusion.auto.auto_combiner:ac-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{AutoCombiner}}}} and the {\hyperref[\detokenize{pusion.auto.generic_combiner:gc-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{GenericCombiner}}}}.
It also ensures uniformity and correct use of all \sphinxtitleref{pusion.core} combiners.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{config}} \textendash{} {\hyperref[\detokenize{pusion.model.configuration:pusion.model.configuration.Configuration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.model.configuration.Configuration}}}}}. User\sphinxhyphen{}defined configuration.

\end{description}\end{quote}
\index{set\_coverage() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{set\_coverage()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.set_coverage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_coverage}}}{\emph{\DUrole{n}{coverage}}}{}
\sphinxAtStartPar
Set the coverage in case of complementary\sphinxhyphen{}redundant classification data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{list} elements. Each inner list contains classes as integers covered by a
classifier, which is identified by the positional index of the respective list. E.g., with
\sphinxcode{\sphinxupquote{{[}{[}0,1{]}, {[}0,2,3{]}{]}}} the classes 0,1 are covered by the first classifier and 0,2,3 are covered by the
second one.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_evidence() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{set\_evidence()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.set_evidence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_evidence}}}{\emph{\DUrole{n}{evidence}}}{}
\sphinxAtStartPar
Set the evidence for evidence\sphinxhyphen{}based combiners. The evidence is given by confusion matrices calculated
according to Kuncheva %
\begin{footnote}[1]\sphinxAtStartFootnote
Ludmila I Kuncheva. \sphinxstyleemphasis{Combining pattern classifiers: methods and algorithms}. John Wiley \& Sons, 2014.
%
\end{footnote}.

\sphinxAtStartPar

\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{evidence}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_classes, n\_classes)}. Confusion matrices
for each ensemble classifier.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_data\_split\_ratio() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{set\_data\_split\_ratio()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.set_data_split_ratio}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_data\_split\_ratio}}}{\emph{\DUrole{n}{validation\_size}}}{}
\sphinxAtStartPar
Set the size of the validation data used by the AutoCombiner to evaluate all applicable fusion methods in order
to select the combiner with the best classification performance.
Accordingly, the other data of size \sphinxtitleref{1\sphinxhyphen{}validation\_size} is used to train all individual combiners.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{validation\_size}} \textendash{} A \sphinxtitleref{float} between \sphinxtitleref{0} and \sphinxtitleref{1.0}. Ratio of the validation data set.

\end{description}\end{quote}

\end{fulllineitems}

\index{train() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{train()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{y\_ensemble\_valid}}, \emph{\DUrole{n}{y\_valid}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Train the combiner model determined by the configuration.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
A trainable combiner is always trained with the validation dataset provided by ensemble classifiers.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_ensemble\_valid}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_valid}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} The \sphinxtitleref{**kwargs} parameter may be used to use additional test data for the AutoFusion selection
procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{combine()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{y\_ensemble\_test}}}{}
\sphinxAtStartPar
Combine decision outputs using the combiner model determined by the configuration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_ensemble\_test}} \textendash{} 
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\sphinxAtStartPar
Tensor of either crisp or continuous decision outputs by different classifiers per sample.


\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. A matrix of crisp or continuous class assignments
which represents fused decisions. Axis 0 represents samples and axis 1 the class labels which are
aligned with axis 2 in \sphinxcode{\sphinxupquote{y\_ensemble\_test}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_multi\_combiner\_decision\_output() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{get\_multi\_combiner\_decision\_output()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.get_multi_combiner_decision_output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_multi\_combiner\_decision\_output}}}{}{}
\sphinxAtStartPar
Retrieve the decision fusion outputs obtained by multiple combiners. This function is only callable for
configurations including \sphinxtitleref{AutoCombiner} or \sphinxtitleref{GenericCombiner} as a method.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{list} of \sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Fusion results obtained by multiple fusion methods.
The list is aligned with the list of preselected fusion methods (retrievable by \sphinxcode{\sphinxupquote{get\_combiners()}}).

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_optimal\_combiner() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{get\_optimal\_combiner()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.get_optimal_combiner}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_optimal\_combiner}}}{\emph{\DUrole{n}{eval\_metric}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Retrieve the combiner with the best classification performance obtained by the framework, i.e. the
\sphinxtitleref{AutoCombiner} or the \sphinxtitleref{GenericCombiner}.
In case of combining with the \sphinxtitleref{GenericCombiner}, an \sphinxtitleref{Evaluation} needs to be set by \sphinxcode{\sphinxupquote{set\_evaluation}}.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
The combiner object.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_combiners() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{get\_combiners()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.get_combiners}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_combiners}}}{}{}
\sphinxAtStartPar
Retrieve combiners (core methods) which are preselected by the framework according to the auto\sphinxhyphen{}detected
configuration.
:return: \sphinxtitleref{list} of combiner objects obtained by the \sphinxtitleref{GenericCombiner} or \sphinxtitleref{AutoCombiner}.

\end{fulllineitems}

\index{get\_combiner() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{get\_combiner()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.get_combiner}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_combiner}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Selected combiner object.

\end{description}\end{quote}

\end{fulllineitems}

\index{report() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{report()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.report}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{report}}}{\emph{\DUrole{n}{eval\_metric}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
The textual evaluation report.

\end{description}\end{quote}

\end{fulllineitems}

\index{info() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{info()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{info}}}{}{}
\sphinxAtStartPar
Retrieve the information, the automatic combiner selection is based on.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar

\sphinxAtStartPar
\sphinxtitleref{tuple} of the form \sphinxtitleref{((A, B, C), D)}, whereby \sphinxtitleref{A} represents the classification problem
\sphinxtitleref{(‘MULTI\_CLASS’ or ‘MULTI\_LABEL’)}, \sphinxtitleref{B} the assignment type \sphinxtitleref{(‘CRISP’ or ‘CONTINUOUS’)} and \sphinxtitleref{C}
the coverage type \sphinxtitleref{(‘REDUNDANT’, ‘COMPLEMENTARY’ or ‘COMPLEMENTARY\_REDUNDANT’)}.

\sphinxAtStartPar
\sphinxtitleref{D} contains the combiner type selection as a \sphinxtitleref{list}.
Possible combiner types are \sphinxtitleref{UtilityBasedCombiner}, \sphinxtitleref{TrainableCombiner} and \sphinxtitleref{EvidenceBasedCombiner}.


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_multi\_combiner\_runtimes() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{get\_multi\_combiner\_runtimes()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.get_multi_combiner_runtimes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_multi\_combiner\_runtimes}}}{}{}
\sphinxAtStartPar
Retrieve the train and combine runtime for each combiner used during a generic fusion.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
A \sphinxtitleref{tuple} of two lists of tuples describing the train and combine runtimes respectively.
Each inner tuple key value indexes the list of preselected fusion methods
(retrievable by \sphinxcode{\sphinxupquote{get\_combiners()}}).

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_evaluation() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{set\_evaluation()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.set_evaluation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_evaluation}}}{\emph{\DUrole{n}{evaluation}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{evaluation}} \textendash{} \sphinxcode{\sphinxupquote{pusion.control.evaluation.Evaluation}} object, a combiner evaluation was
performed with.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_parallel() (pusion.control.decision\_processor.DecisionProcessor method)@\spxentry{set\_parallel()}\spxextra{pusion.control.decision\_processor.DecisionProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.control.decision_processor:pusion.control.decision_processor.DecisionProcessor.set_parallel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_parallel}}}{\emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Set whether the training and the combining of selected combiners should be executed sequentially or in parallel.
:param parallel: If \sphinxtitleref{True}, training and combining is performed in parallel respectively. Otherwise in sequence.

\end{fulllineitems}


\end{fulllineitems}



\section{pusion.core package}
\label{\detokenize{pusion.core:pusion-core-package}}\label{\detokenize{pusion.core::doc}}

\subsection{pusion.core.behaviour\_knowledge\_space\_combiner}
\label{\detokenize{pusion.core.behaviour_knowledge_space_combiner:module-pusion.core.behaviour_knowledge_space_combiner}}\label{\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion-core-behaviour-knowledge-space-combiner}}\label{\detokenize{pusion.core.behaviour_knowledge_space_combiner:bks-cref}}\label{\detokenize{pusion.core.behaviour_knowledge_space_combiner::doc}}\index{module@\spxentry{module}!pusion.core.behaviour\_knowledge\_space\_combiner@\spxentry{pusion.core.behaviour\_knowledge\_space\_combiner}}\index{pusion.core.behaviour\_knowledge\_space\_combiner@\spxentry{pusion.core.behaviour\_knowledge\_space\_combiner}!module@\spxentry{module}}\index{BehaviourKnowledgeSpaceCombiner (class in pusion.core.behaviour\_knowledge\_space\_combiner)@\spxentry{BehaviourKnowledgeSpaceCombiner}\spxextra{class in pusion.core.behaviour\_knowledge\_space\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.BehaviourKnowledgeSpaceCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.behaviour\_knowledge\_space\_combiner.}}\sphinxbfcode{\sphinxupquote{BehaviourKnowledgeSpaceCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.TrainableCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.BehaviourKnowledgeSpaceCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BehaviourKnowledgeSpaceCombiner}}}}} (BKS) is adopted from the decision fusion method originally proposed by
Huang, Suen et al. %
\begin{footnote}[1]\sphinxAtStartFootnote
Yea S Huang and Ching Y Suen. The behavior\sphinxhyphen{}knowledge space method for combination of multiple classifiers. In \sphinxstyleemphasis{IEEE computer society conference on computer vision and pattern recognition}, 347\textendash{}347. Institute of Electrical Engineers Inc (IEEE), 1993.
%
\end{footnote}. BKS analyses the behaviour of multiple classifiers based on their
classification outputs with respect to each available class.
This behaviour is recorded by means of a lookup table, which is used for final combination of multiple
classification outputs for a sample.

\sphinxAtStartPar

\index{train() (pusion.core.behaviour\_knowledge\_space\_combiner.BehaviourKnowledgeSpaceCombiner method)@\spxentry{train()}\spxextra{pusion.core.behaviour\_knowledge\_space\_combiner.BehaviourKnowledgeSpaceCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.BehaviourKnowledgeSpaceCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Behaviour Knowledge Space model (BKS) by extracting the classification configuration from all
classifiers and summarizing samples of each true class that leads to that configuration. This relationship is
recorded in a lookup table. Only crisp classification outputs are supported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.behaviour\_knowledge\_space\_combiner.BehaviourKnowledgeSpaceCombiner method)@\spxentry{combine()}\spxextra{pusion.core.behaviour\_knowledge\_space\_combiner.BehaviourKnowledgeSpaceCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.BehaviourKnowledgeSpaceCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by the Behaviour Knowledge Space (BKS) method. This procedure involves looking up the
most representative class for a given classification output regarding the behaviour of all classifiers in the
ensemble. Only crisp classification outputs are supported. If a trained lookup entry is not present for a
certain classification configuration, no decision fusion can be made for the sample, which led to that
configuration. In this case, the decision fusion is a zero vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp class assignments which are obtained by the best representative class
for a certain classifier’s behaviour per sample. Axis 0 represents samples and axis 1 the class labels
which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRBehaviourKnowledgeSpaceCombiner (class in pusion.core.behaviour\_knowledge\_space\_combiner)@\spxentry{CRBehaviourKnowledgeSpaceCombiner}\spxextra{class in pusion.core.behaviour\_knowledge\_space\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.CRBehaviourKnowledgeSpaceCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.behaviour\_knowledge\_space\_combiner.}}\sphinxbfcode{\sphinxupquote{CRBehaviourKnowledgeSpaceCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.BehaviourKnowledgeSpaceCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.behaviour\_knowledge\_space\_combiner.BehaviourKnowledgeSpaceCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.CRBehaviourKnowledgeSpaceCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRBehaviourKnowledgeSpaceCombiner}}}}} is a modification of {\hyperref[\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.BehaviourKnowledgeSpaceCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BehaviourKnowledgeSpaceCombiner}}}}} that
also supports complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed, such that all missing
classification assignments are considered as a constant, respectively. To use methods {\hyperref[\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.CRBehaviourKnowledgeSpaceCombiner.train}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{train()}}}}} and
{\hyperref[\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.CRBehaviourKnowledgeSpaceCombiner.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}} a coverage needs to be set first by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{train() (pusion.core.behaviour\_knowledge\_space\_combiner.CRBehaviourKnowledgeSpaceCombiner method)@\spxentry{train()}\spxextra{pusion.core.behaviour\_knowledge\_space\_combiner.CRBehaviourKnowledgeSpaceCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.CRBehaviourKnowledgeSpaceCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Behaviour Knowledge Space model (BKS) by extracting the classification configuration from all
classifiers and summarizing samples of each true class that leads to that configuration. This relationship is
recorded in a lookup table. Only crisp classification outputs are supported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp decision outputs
per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which is considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.behaviour\_knowledge\_space\_combiner.CRBehaviourKnowledgeSpaceCombiner method)@\spxentry{combine()}\spxextra{pusion.core.behaviour\_knowledge\_space\_combiner.CRBehaviourKnowledgeSpaceCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.behaviour_knowledge_space_combiner:pusion.core.behaviour_knowledge_space_combiner.CRBehaviourKnowledgeSpaceCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine decision outputs by the Behaviour Knowledge Space (BKS) method. This procedure involves looking up the
most representative class for a given classification output regarding the behaviour of all classifiers in the
ensemble. Only crisp classification outputs are supported. If a trained lookup entry is not present for a
certain classification configuration, no decision fusion can be made for the sample, which led to that
configuration. In this case, the decision fusion is a zero vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp decision outputs
per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp class assignments which are obtained by the best representative class
for a certain classifier’s behaviour per sample. Axis 0 represents samples and axis 1 all the class
labels which are provided by the coverage.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.borda\_count\_combiner}
\label{\detokenize{pusion.core.borda_count_combiner:module-pusion.core.borda_count_combiner}}\label{\detokenize{pusion.core.borda_count_combiner:pusion-core-borda-count-combiner}}\label{\detokenize{pusion.core.borda_count_combiner:bc-cref}}\label{\detokenize{pusion.core.borda_count_combiner::doc}}\index{module@\spxentry{module}!pusion.core.borda\_count\_combiner@\spxentry{pusion.core.borda\_count\_combiner}}\index{pusion.core.borda\_count\_combiner@\spxentry{pusion.core.borda\_count\_combiner}!module@\spxentry{module}}\index{BordaCountCombiner (class in pusion.core.borda\_count\_combiner)@\spxentry{BordaCountCombiner}\spxextra{class in pusion.core.borda\_count\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.borda_count_combiner:pusion.core.borda_count_combiner.BordaCountCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.borda\_count\_combiner.}}\sphinxbfcode{\sphinxupquote{BordaCountCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.UtilityBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.UtilityBasedCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.borda_count_combiner:pusion.core.borda_count_combiner.BordaCountCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BordaCountCombiner}}}}} (BC) is a decision fusion method that establishes a ranking between label
assignments for a sample. This ranking is implicitly given by continuous support outputs and is mapped to different
amounts of votes (\(0\) of \(L\) votes for the lowest support, and \(L-1\) votes for the highest one).
A class with the highest sum of these votes (borda counts) across all classifiers is considered as a winner for the
final decision.
\index{combine() (pusion.core.borda\_count\_combiner.BordaCountCombiner method)@\spxentry{combine()}\spxextra{pusion.core.borda\_count\_combiner.BordaCountCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.borda_count_combiner:pusion.core.borda_count_combiner.BordaCountCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by the Borda Count (BC) method. Firstly, the continuous classification is mapped to a
ranking with respect to available classes for each sample. Those rankings are then summed up across all
classifiers to establish total votes (borda counts) for each class in a sample. The class with the highest
number of borda counts is considered as decision fusion. Only continuous classification outputs are supported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of continuous decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp class assignments which represents fused decisions.
Axis 0 represents samples and axis 1 the class labels which are aligned with axis 2 in
\sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRBordaCountCombiner (class in pusion.core.borda\_count\_combiner)@\spxentry{CRBordaCountCombiner}\spxextra{class in pusion.core.borda\_count\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.borda_count_combiner:pusion.core.borda_count_combiner.CRBordaCountCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.borda\_count\_combiner.}}\sphinxbfcode{\sphinxupquote{CRBordaCountCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.borda_count_combiner:pusion.core.borda_count_combiner.BordaCountCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.borda\_count\_combiner.BordaCountCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.borda_count_combiner:pusion.core.borda_count_combiner.CRBordaCountCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRBordaCountCombiner}}}}} is a modification of {\hyperref[\detokenize{pusion.core.borda_count_combiner:pusion.core.borda_count_combiner.BordaCountCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BordaCountCombiner}}}}} that also supports
complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed, such that all missing classification
assignments are considered as \sphinxtitleref{0}, respectively. To call {\hyperref[\detokenize{pusion.core.borda_count_combiner:pusion.core.borda_count_combiner.CRBordaCountCombiner.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}} a coverage needs to be set first
by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{combine() (pusion.core.borda\_count\_combiner.CRBordaCountCombiner method)@\spxentry{combine()}\spxextra{pusion.core.borda\_count\_combiner.CRBordaCountCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.borda_count_combiner:pusion.core.borda_count_combiner.CRBordaCountCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine complementary\sphinxhyphen{}redundant decision outputs by the Borda Count (BC) method. Firstly, the continuous
classification is mapped to a ranking with respect to available classes for each sample. Those rankings are then
summed up across all classifiers to establish total votes (borda counts) for each class in a sample. The class
with the highest number of borda counts is considered as decision fusion. Only continuous classification outputs
are supported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains continuous decision outputs
per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp class assignments which represents fused decisions.
Axis 0 represents samples and axis 1 the class labels which are aligned with axis 2 in
\sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.combiner}
\label{\detokenize{pusion.core.combiner:module-pusion.core.combiner}}\label{\detokenize{pusion.core.combiner:pusion-core-combiner}}\label{\detokenize{pusion.core.combiner::doc}}\index{module@\spxentry{module}!pusion.core.combiner@\spxentry{pusion.core.combiner}}\index{pusion.core.combiner@\spxentry{pusion.core.combiner}!module@\spxentry{module}}\index{Combiner (class in pusion.core.combiner)@\spxentry{Combiner}\spxextra{class in pusion.core.combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.Combiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.combiner.}}\sphinxbfcode{\sphinxupquote{Combiner}}}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Combiner’s root class. This class as well as the subclasses in this module set the structure for each combiner
provided by the framework. It also accommodates methods and attributes which are essential for combiner’s
registration and obtainment.

\sphinxAtStartPar
Each combiner to be registered in the framework, needs to base at least one of the following classes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.UtilityBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UtilityBasedCombiner}}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TrainableCombiner}}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.EvidenceBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EvidenceBasedCombiner}}}}}.

\end{itemize}

\sphinxAtStartPar
Furthermore, it needs a \sphinxtitleref{list} \sphinxcode{\sphinxupquote{\_SUPPORTED\_PAC}} of supported PAC tuples set as a class attribute.
A PAC tuple is a \sphinxtitleref{tuple} of string constants (classification problem, assignment type and coverage type). See:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{pusion.util.constants.Problem}

\item {} 
\sphinxAtStartPar
\sphinxtitleref{pusion.util.constants.AssignmentType}

\item {} 
\sphinxAtStartPar
\sphinxtitleref{pusion.util.constants.CoverageType}

\end{itemize}

\sphinxAtStartPar
respectively. Example of a new combiner:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{NewCombiner}\PYG{p}{(}\PYG{n}{TrainableCombiner}\PYG{p}{)}\PYG{p}{:}

\PYG{n}{\PYGZus{}SUPPORTED\PYGZus{}PAC} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{(}\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{MULTI\PYGZus{}CLASS}\PYG{p}{,} \PYG{n}{AssignmentType}\PYG{o}{.}\PYG{n}{CRISP}\PYG{p}{,} \PYG{n}{CoverageType}\PYG{o}{.}\PYG{n}{REDUNDANT}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{MULTI\PYGZus{}CLASS}\PYG{p}{,} \PYG{n}{AssignmentType}\PYG{o}{.}\PYG{n}{CONTINUOUS}\PYG{p}{,} \PYG{n}{CoverageType}\PYG{o}{.}\PYG{n}{REDUNDANT}\PYG{p}{)}
\PYG{p}{]}

\PYG{k}{def} \PYG{n+nf}{train}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{decision\PYGZus{}outputs}\PYG{p}{,} \PYG{n}{true\PYGZus{}assignments}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}

\PYG{k}{def} \PYG{n+nf}{combine}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{decision\PYGZus{}outputs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Note that a new combiner also needs to be inserted into the \sphinxcode{\sphinxupquote{pusion.Method}} class within
\sphinxtitleref{pusion.\_\_init\_\_.py} file.
\end{sphinxadmonition}
\index{obtain() (pusion.core.combiner.Combiner class method)@\spxentry{obtain()}\spxextra{pusion.core.combiner.Combiner class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.Combiner.obtain}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{obtain}}}{\emph{\DUrole{n}{config}}}{}
\sphinxAtStartPar
Obtain a combiner registered by the framework.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{config}} \textendash{} {\hyperref[\detokenize{pusion.model.configuration:pusion.model.configuration.Configuration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.model.configuration.Configuration}}}}}. User\sphinxhyphen{}defined configuration.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A \sphinxtitleref{combiner} object.

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.combiner.Combiner method)@\spxentry{combine()}\spxextra{pusion.core.combiner.Combiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.Combiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Abstract method. Combine decision outputs by combiner’s implementation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. A matrix of class assignments which represents fused
decisions obtained by combiner’s implementation. Axis 0 represents samples and axis 1 the class
assignments which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_coverage() (pusion.core.combiner.Combiner method)@\spxentry{set\_coverage()}\spxextra{pusion.core.combiner.Combiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.Combiner.set_coverage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_coverage}}}{\emph{\DUrole{n}{coverage}}}{}
\sphinxAtStartPar
Set the coverage for complementary\sphinxhyphen{}redundant decisions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{list} elements. Each inner list contains classes as integers covered by a
classifier, which is identified by the positional index of the respective list.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{UtilityBasedCombiner (class in pusion.core.combiner)@\spxentry{UtilityBasedCombiner}\spxextra{class in pusion.core.combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.UtilityBasedCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.combiner.}}\sphinxbfcode{\sphinxupquote{UtilityBasedCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.Combiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.Combiner}}}}}

\sphinxAtStartPar
A combiner of type {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.UtilityBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UtilityBasedCombiner}}}}} fuses decisions solely based on the outputs of the ensemble
classifiers. It does not take any further information or evidence about respective ensemble classifiers into
account.
\index{combine() (pusion.core.combiner.UtilityBasedCombiner method)@\spxentry{combine()}\spxextra{pusion.core.combiner.UtilityBasedCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.UtilityBasedCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Abstract method. Combine decision outputs by combiner’s implementation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. A matrix of class assignments which represents fused
decisions obtained by combiner’s implementation. Axis 0 represents samples and axis 1 the class
assignments which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TrainableCombiner (class in pusion.core.combiner)@\spxentry{TrainableCombiner}\spxextra{class in pusion.core.combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.combiner.}}\sphinxbfcode{\sphinxupquote{TrainableCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.Combiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.Combiner}}}}}

\sphinxAtStartPar
A combiner of type {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TrainableCombiner}}}}} needs to be trained using decision outputs of the ensemble classifiers
with true class assignments in order to combine decisions of unknown samples.
\index{combine() (pusion.core.combiner.TrainableCombiner method)@\spxentry{combine()}\spxextra{pusion.core.combiner.TrainableCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Abstract method. Combine decision outputs by combiner’s implementation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. A matrix of class assignments which represents fused
decisions obtained by combiner’s implementation. Axis 0 represents samples and axis 1 the class
assignments which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}

\index{train() (pusion.core.combiner.TrainableCombiner method)@\spxentry{train()}\spxextra{pusion.core.combiner.TrainableCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Abstract method. Train combiner’s implementation using decision outputs an appropriate true assignments.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of class assignments which are considered true for each sample during the training procedure.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} The \sphinxtitleref{**kwargs} parameter may be used to use additional test data for the AutoFusion selection
procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{EvidenceBasedCombiner (class in pusion.core.combiner)@\spxentry{EvidenceBasedCombiner}\spxextra{class in pusion.core.combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.EvidenceBasedCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.combiner.}}\sphinxbfcode{\sphinxupquote{EvidenceBasedCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.Combiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.Combiner}}}}}

\sphinxAtStartPar
A combiner of type {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.EvidenceBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EvidenceBasedCombiner}}}}} takes an additional evidence into account while combining outputs
of ensemble classifiers. Thus, it is able to empower better classifiers in order to obtain a fusion result with
higher overall classification performance.
\index{combine() (pusion.core.combiner.EvidenceBasedCombiner method)@\spxentry{combine()}\spxextra{pusion.core.combiner.EvidenceBasedCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.EvidenceBasedCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Abstract method. Combine decision outputs by combiner’s implementation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. A matrix of class assignments which represents fused
decisions obtained by combiner’s implementation. Axis 0 represents samples and axis 1 the class
assignments which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_evidence() (pusion.core.combiner.EvidenceBasedCombiner method)@\spxentry{set\_evidence()}\spxextra{pusion.core.combiner.EvidenceBasedCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.combiner:pusion.core.combiner.EvidenceBasedCombiner.set_evidence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{set\_evidence}}}{\emph{\DUrole{n}{evidence}}}{}
\sphinxAtStartPar
Abstract method. Set the evidence for evidence\sphinxhyphen{}based combiner implementations.
The evidence is given by confusion matrices calculated according to Kuncheva %
\begin{footnote}[1]\sphinxAtStartFootnote
Ludmila I Kuncheva. \sphinxstyleemphasis{Combining pattern classifiers: methods and algorithms}. John Wiley \& Sons, 2014.
%
\end{footnote}.

\sphinxAtStartPar

\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{evidence}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_classes, n\_classes)}. Confusion matrices
for each ensemble classifier.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.cosine\_similarity\_combiner}
\label{\detokenize{pusion.core.cosine_similarity_combiner:module-pusion.core.cosine_similarity_combiner}}\label{\detokenize{pusion.core.cosine_similarity_combiner:pusion-core-cosine-similarity-combiner}}\label{\detokenize{pusion.core.cosine_similarity_combiner:cos-cref}}\label{\detokenize{pusion.core.cosine_similarity_combiner::doc}}\index{module@\spxentry{module}!pusion.core.cosine\_similarity\_combiner@\spxentry{pusion.core.cosine\_similarity\_combiner}}\index{pusion.core.cosine\_similarity\_combiner@\spxentry{pusion.core.cosine\_similarity\_combiner}!module@\spxentry{module}}\index{CosineSimilarityCombiner (class in pusion.core.cosine\_similarity\_combiner)@\spxentry{CosineSimilarityCombiner}\spxextra{class in pusion.core.cosine\_similarity\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.cosine_similarity_combiner:pusion.core.cosine_similarity_combiner.CosineSimilarityCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.cosine\_similarity\_combiner.}}\sphinxbfcode{\sphinxupquote{CosineSimilarityCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.UtilityBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.UtilityBasedCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.cosine_similarity_combiner:pusion.core.cosine_similarity_combiner.CosineSimilarityCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CosineSimilarityCombiner}}}}} considers the classification assignments to \(\ell\) classes as vectors
from an \(\ell\)\sphinxhyphen{}dimensional vector space. The normalized cosine\sphinxhyphen{}similarity measure between two vectors
\(x\) and \(y\) is calculated as
\begin{equation*}
\begin{split}cos(x,y) = \dfrac{x\cdot y}{|x||y|}\ .\end{split}
\end{equation*}
\sphinxAtStartPar
The cosine\sphinxhyphen{}similarity is calculated pairwise and accumulated for each classifier for one specific sample.
The fusion is represented by a classifier which shows the most similar classification output to the output of all
competing classifiers.
\index{combine() (pusion.core.cosine\_similarity\_combiner.CosineSimilarityCombiner method)@\spxentry{combine()}\spxextra{pusion.core.cosine\_similarity\_combiner.CosineSimilarityCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.cosine_similarity_combiner:pusion.core.cosine_similarity_combiner.CosineSimilarityCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs with as an output that accommodates the highest cosine\sphinxhyphen{}similarity to the output of
all competing classifiers. In other words, the best representative classification output among the others is
selected according to the highest cumulative cosine\sphinxhyphen{}similarity. This method supports both, continuous and
crisp classification outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of either crisp or continuous class assignments which represents fused
decisions obtained by the highest cumulative cosine\sphinxhyphen{}similarity. Axis 0 represents samples and axis 1 the
class labels which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRCosineSimilarity (class in pusion.core.cosine\_similarity\_combiner)@\spxentry{CRCosineSimilarity}\spxextra{class in pusion.core.cosine\_similarity\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.cosine_similarity_combiner:pusion.core.cosine_similarity_combiner.CRCosineSimilarity}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.cosine\_similarity\_combiner.}}\sphinxbfcode{\sphinxupquote{CRCosineSimilarity}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.cosine_similarity_combiner:pusion.core.cosine_similarity_combiner.CosineSimilarityCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.cosine\_similarity\_combiner.CosineSimilarityCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.cosine_similarity_combiner:pusion.core.cosine_similarity_combiner.CRCosineSimilarity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRCosineSimilarity}}}}} is a modification of {\hyperref[\detokenize{pusion.core.cosine_similarity_combiner:pusion.core.cosine_similarity_combiner.CosineSimilarityCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CosineSimilarityCombiner}}}}} that also supports
complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed, such that all missing classification
assignments are considered as \sphinxtitleref{0}, respectively. To call {\hyperref[\detokenize{pusion.core.cosine_similarity_combiner:pusion.core.cosine_similarity_combiner.CRCosineSimilarity.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}} a coverage needs to be set first
by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{combine() (pusion.core.cosine\_similarity\_combiner.CRCosineSimilarity method)@\spxentry{combine()}\spxextra{pusion.core.cosine\_similarity\_combiner.CRCosineSimilarity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.cosine_similarity_combiner:pusion.core.cosine_similarity_combiner.CRCosineSimilarity.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine complementary\sphinxhyphen{}redundant decision outputs with as an output that accommodates the highest
cosine\sphinxhyphen{}similarity to the output of all competing classifiers. In other words, the best representative
classification output among the others is selected according to the highest cumulative cosine\sphinxhyphen{}similarity.
This method supports both, continuous and crisp classification outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage. Each matrix corresponds to
one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp or continuous decision outputs per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp or continuous class assignments which represents fused decisions.
Axis 0 represents samples and axis 1 the class labels which are aligned with axis 2 in
\sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.decision\_templates\_combiner}
\label{\detokenize{pusion.core.decision_templates_combiner:module-pusion.core.decision_templates_combiner}}\label{\detokenize{pusion.core.decision_templates_combiner:pusion-core-decision-templates-combiner}}\label{\detokenize{pusion.core.decision_templates_combiner:dt-cref}}\label{\detokenize{pusion.core.decision_templates_combiner::doc}}\index{module@\spxentry{module}!pusion.core.decision\_templates\_combiner@\spxentry{pusion.core.decision\_templates\_combiner}}\index{pusion.core.decision\_templates\_combiner@\spxentry{pusion.core.decision\_templates\_combiner}!module@\spxentry{module}}\index{DecisionTemplatesCombiner (class in pusion.core.decision\_templates\_combiner)@\spxentry{DecisionTemplatesCombiner}\spxextra{class in pusion.core.decision\_templates\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.DecisionTemplatesCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.decision\_templates\_combiner.}}\sphinxbfcode{\sphinxupquote{DecisionTemplatesCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.TrainableCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.DecisionTemplatesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DecisionTemplatesCombiner}}}}} (DT) is adopted from the decision fusion method originally proposed by
Kuncheva %
\begin{footnote}[1]\sphinxAtStartFootnote
Ludmila I Kuncheva. \sphinxstyleemphasis{Combining pattern classifiers: methods and algorithms}. John Wiley \& Sons, 2014.
%
\end{footnote}. A decision template is the average matrix of all decision profiles,
which correspond to samples of one specific class. A decision profile contains classification outputs from all
classifiers for a sample in a row\sphinxhyphen{}wise fashion. The decision fusion is performed based on distance calculations
between decision templates and the decision profile generated from the ensemble outputs.

\sphinxAtStartPar

\index{train() (pusion.core.decision\_templates\_combiner.DecisionTemplatesCombiner method)@\spxentry{train()}\spxextra{pusion.core.decision\_templates\_combiner.DecisionTemplatesCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.DecisionTemplatesCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Decision Templates Combiner model by precalculating decision templates from given decision outputs and
true class assignments. Both continuous and crisp classification outputs are supported. This procedure involves
calculating means of decision profiles (decision templates) for each true class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.decision\_templates\_combiner.DecisionTemplatesCombiner method)@\spxentry{combine()}\spxextra{pusion.core.decision\_templates\_combiner.DecisionTemplatesCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.DecisionTemplatesCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by using the Decision Templates method.
Both continuous and crisp classification outputs are supported. Combining requires a trained
{\hyperref[\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.DecisionTemplatesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DecisionTemplatesCombiner}}}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of either crisp or continuous class assignments which represents fused
decisions obtained by the minimum distance between decision profiles of \sphinxcode{\sphinxupquote{decision\_tensor}} and
precalculated decision templates. Axis 0 represents samples and axis 1 the class assignments which
are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRDecisionTemplatesCombiner (class in pusion.core.decision\_templates\_combiner)@\spxentry{CRDecisionTemplatesCombiner}\spxextra{class in pusion.core.decision\_templates\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.CRDecisionTemplatesCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.decision\_templates\_combiner.}}\sphinxbfcode{\sphinxupquote{CRDecisionTemplatesCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.DecisionTemplatesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.decision\_templates\_combiner.DecisionTemplatesCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.CRDecisionTemplatesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRDecisionTemplatesCombiner}}}}} is a modification of {\hyperref[\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.DecisionTemplatesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DecisionTemplatesCombiner}}}}} that
also supports complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed, such that all missing
classification assignments are considered as a constant, respectively. To use methods {\hyperref[\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.CRDecisionTemplatesCombiner.train}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{train()}}}}} and
{\hyperref[\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.CRDecisionTemplatesCombiner.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}} a coverage needs to be set first by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{train() (pusion.core.decision\_templates\_combiner.CRDecisionTemplatesCombiner method)@\spxentry{train()}\spxextra{pusion.core.decision\_templates\_combiner.CRDecisionTemplatesCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.CRDecisionTemplatesCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Decision Templates Combiner model by precalculating decision templates from given decision outputs and
true class assignments. Both continuous and crisp classification outputs are supported. This procedure involves
calculating means of decision profiles (decision templates) for each true class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains either crisp or continuous
decision outputs per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.decision\_templates\_combiner.CRDecisionTemplatesCombiner method)@\spxentry{combine()}\spxextra{pusion.core.decision\_templates\_combiner.CRDecisionTemplatesCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.CRDecisionTemplatesCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine decision outputs by using the Decision Templates method.
Both continuous and crisp classification outputs are supported. Combining requires a trained
{\hyperref[\detokenize{pusion.core.decision_templates_combiner:pusion.core.decision_templates_combiner.CRDecisionTemplatesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRDecisionTemplatesCombiner}}}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage. Each matrix corresponds to
one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp or continuous decision outputs per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp or continuous class assignments which represents fused decisions.
Axis 0 represents samples and axis 1 the class labels which are aligned with axis 2 in
\sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.k\_nearest\_neighbors\_combiner.py}
\label{\detokenize{pusion.core.k_nearest_neighbors_combiner:module-pusion.core.k_nearest_neighbors_combiner}}\label{\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion-core-k-nearest-neighbors-combiner-py}}\label{\detokenize{pusion.core.k_nearest_neighbors_combiner:knn-cref}}\label{\detokenize{pusion.core.k_nearest_neighbors_combiner::doc}}\index{module@\spxentry{module}!pusion.core.k\_nearest\_neighbors\_combiner@\spxentry{pusion.core.k\_nearest\_neighbors\_combiner}}\index{pusion.core.k\_nearest\_neighbors\_combiner@\spxentry{pusion.core.k\_nearest\_neighbors\_combiner}!module@\spxentry{module}}\index{KNNCombiner (class in pusion.core.k\_nearest\_neighbors\_combiner)@\spxentry{KNNCombiner}\spxextra{class in pusion.core.k\_nearest\_neighbors\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.KNNCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.k\_nearest\_neighbors\_combiner.}}\sphinxbfcode{\sphinxupquote{KNNCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.TrainableCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.KNNCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{KNNCombiner}}}}} (kNN) is a learning and classifier\sphinxhyphen{}based combiner that converts multiple decision
outputs into new features, which in turn are used to train this combiner.
The kNN combiner (k=5) uses uniform weights for all neighbors and the standard Euclidean metric for the distance.
\index{train() (pusion.core.k\_nearest\_neighbors\_combiner.KNNCombiner method)@\spxentry{train()}\spxextra{pusion.core.k\_nearest\_neighbors\_combiner.KNNCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.KNNCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the kNN combiner by fitting the \sphinxtitleref{k} nearest neighbors (k=5) model with given decision outputs and
true class assignments. Both continuous and crisp classification outputs are supported.
This procedure transforms decision outputs into a new feature space.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.k\_nearest\_neighbors\_combiner.KNNCombiner method)@\spxentry{combine()}\spxextra{pusion.core.k\_nearest\_neighbors\_combiner.KNNCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.KNNCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by the \sphinxtitleref{k} nearest neighbors (k=5) model.
Both continuous and crisp classification outputs are supported. Combining requires a trained
\sphinxcode{\sphinxupquote{DecisionTreeCombiner}}.
This procedure transforms decision outputs into a new feature space.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of either crisp or continuous class assignments which represents fused
decisions obtained by kNN. Axis 0 represents samples and axis 1 the class
assignments which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRKNNCombiner (class in pusion.core.k\_nearest\_neighbors\_combiner)@\spxentry{CRKNNCombiner}\spxextra{class in pusion.core.k\_nearest\_neighbors\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.CRKNNCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.k\_nearest\_neighbors\_combiner.}}\sphinxbfcode{\sphinxupquote{CRKNNCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.KNNCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.k\_nearest\_neighbors\_combiner.KNNCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.CRKNNCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRKNNCombiner}}}}} is a modification of {\hyperref[\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.KNNCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{KNNCombiner}}}}} that
also supports complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed, such that all missing
classification assignments are considered as a constant, respectively. To use methods {\hyperref[\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.CRKNNCombiner.train}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{train()}}}}} and
{\hyperref[\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.CRKNNCombiner.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}} a coverage needs to be set first by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{train() (pusion.core.k\_nearest\_neighbors\_combiner.CRKNNCombiner method)@\spxentry{train()}\spxextra{pusion.core.k\_nearest\_neighbors\_combiner.CRKNNCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.CRKNNCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the kNN combiner model by fitting the \sphinxtitleref{k} nearest neighbors (k=5) model with given decision outputs and
true class assignments. Both continuous and crisp classification outputs are supported.
This procedure transforms decision outputs into a new feature space.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains either crisp or continuous
decision outputs per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.k\_nearest\_neighbors\_combiner.CRKNNCombiner method)@\spxentry{combine()}\spxextra{pusion.core.k\_nearest\_neighbors\_combiner.CRKNNCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.k_nearest_neighbors_combiner:pusion.core.k_nearest_neighbors_combiner.CRKNNCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine decision outputs by the \sphinxtitleref{k} nearest neighbors (k=5) model.
Both continuous and crisp classification outputs are supported. Combining requires a trained
\sphinxcode{\sphinxupquote{DecisionTreeCombiner}}.
This procedure transforms decision outputs into a new feature space.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage. Each matrix corresponds to
one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp or continuous decision outputs per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp or continuous class assignments which represents fused decisions.
Axis 0 represents samples and axis 1 the class labels which are aligned with axis 2 in
\sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.dempster\_shafer\_combiner}
\label{\detokenize{pusion.core.dempster_shafer_combiner:module-pusion.core.dempster_shafer_combiner}}\label{\detokenize{pusion.core.dempster_shafer_combiner:pusion-core-dempster-shafer-combiner}}\label{\detokenize{pusion.core.dempster_shafer_combiner:ds-cref}}\label{\detokenize{pusion.core.dempster_shafer_combiner::doc}}\index{module@\spxentry{module}!pusion.core.dempster\_shafer\_combiner@\spxentry{pusion.core.dempster\_shafer\_combiner}}\index{pusion.core.dempster\_shafer\_combiner@\spxentry{pusion.core.dempster\_shafer\_combiner}!module@\spxentry{module}}\index{DempsterShaferCombiner (class in pusion.core.dempster\_shafer\_combiner)@\spxentry{DempsterShaferCombiner}\spxextra{class in pusion.core.dempster\_shafer\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.DempsterShaferCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.dempster\_shafer\_combiner.}}\sphinxbfcode{\sphinxupquote{DempsterShaferCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.TrainableCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.DempsterShaferCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DempsterShaferCombiner}}}}} (DS) fuses decision outputs by means of the Dempster Shafer evidence theory
referenced by Polikar %
\begin{footnote}[1]\sphinxAtStartFootnote
Robi Polikar. Ensemble based systems in decision making. \sphinxstyleemphasis{IEEE Circuits and systems magazine}, 6(3):21\textendash{}45, 2006.
%
\end{footnote} and Ghosh et al. %
\begin{footnote}[2]\sphinxAtStartFootnote
Kaushik Ghosh, Yew Seng Ng, and Rajagopalan Srinivasan. Evaluation of decision fusion strategies for effective collaboration among heterogeneous fault diagnostic methods. \sphinxstyleemphasis{Computers \& chemical engineering}, 35(2):342\textendash{}355, 2011.
%
\end{footnote}.
DS involves computing the \sphinxtitleref{proximity} and \sphinxtitleref{belief} values per classifier and class, depending on a sample.
Then, the total class support is calculated using the Dempster’s rule as the product of belief values across all
classifiers to each class, respectively. The class with the highest product is considered as a fused decision.
DS shares the same training procedure with the \sphinxcode{\sphinxupquote{DecisionTemplatesCombiner}}.

\sphinxAtStartPar

\index{train() (pusion.core.dempster\_shafer\_combiner.DempsterShaferCombiner method)@\spxentry{train()}\spxextra{pusion.core.dempster\_shafer\_combiner.DempsterShaferCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.DempsterShaferCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Dempster Shafer Combiner model by precalculating decision templates from given decision outputs and
true class assignments. Both continuous and crisp classification outputs are supported. This procedure involves
calculations mean decision profiles (decision templates) for each true class assignment.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.dempster\_shafer\_combiner.DempsterShaferCombiner method)@\spxentry{combine()}\spxextra{pusion.core.dempster\_shafer\_combiner.DempsterShaferCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.DempsterShaferCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by using the Dempster Shafer method.
Both continuous and crisp classification outputs are supported. Combining requires a trained
{\hyperref[\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.DempsterShaferCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DempsterShaferCombiner}}}}}.
This procedure involves computing the proximity, the belief values, and the total class support using the
Dempster’s rule.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of either crisp or continuous class assignments which represents fused
decisions obtained by the maximum class support. Axis 0 represents samples and axis 1 the class
assignments which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRDempsterShaferCombiner (class in pusion.core.dempster\_shafer\_combiner)@\spxentry{CRDempsterShaferCombiner}\spxextra{class in pusion.core.dempster\_shafer\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.CRDempsterShaferCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.dempster\_shafer\_combiner.}}\sphinxbfcode{\sphinxupquote{CRDempsterShaferCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.DempsterShaferCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.dempster\_shafer\_combiner.DempsterShaferCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.CRDempsterShaferCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRDempsterShaferCombiner}}}}} is a modification of {\hyperref[\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.DempsterShaferCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DempsterShaferCombiner}}}}} that
also supports complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed, such that all missing
classification assignments are considered as a constant, respectively. To use methods {\hyperref[\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.CRDempsterShaferCombiner.train}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{train()}}}}} and
{\hyperref[\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.CRDempsterShaferCombiner.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}} a coverage needs to be set first by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{train() (pusion.core.dempster\_shafer\_combiner.CRDempsterShaferCombiner method)@\spxentry{train()}\spxextra{pusion.core.dempster\_shafer\_combiner.CRDempsterShaferCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.CRDempsterShaferCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Dempster Shafer Combiner model by precalculating decision templates from given decision outputs and
true class assignments. Both continuous and crisp classification outputs are supported. This procedure involves
calculations mean decision profiles (decision templates) for each true class assignment.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains either crisp or continuous
decision outputs per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.dempster\_shafer\_combiner.CRDempsterShaferCombiner method)@\spxentry{combine()}\spxextra{pusion.core.dempster\_shafer\_combiner.CRDempsterShaferCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.CRDempsterShaferCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine decision outputs by using the Dempster Shafer method.
Both continuous and crisp classification outputs are supported. Combining requires a trained
{\hyperref[\detokenize{pusion.core.dempster_shafer_combiner:pusion.core.dempster_shafer_combiner.DempsterShaferCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DempsterShaferCombiner}}}}}.
This procedure involves computing the proximity, the belief values, and the total class support using the
Dempster’s rule.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage. Each matrix corresponds to
one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp or continuous decision outputs per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp or continuous class assignments which represents fused decisions.
Axis 0 represents samples and axis 1 the class labels which are aligned with axis 2 in
\sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.macro\_majority\_vote\_combiner}
\label{\detokenize{pusion.core.macro_majority_vote_combiner:module-pusion.core.macro_majority_vote_combiner}}\label{\detokenize{pusion.core.macro_majority_vote_combiner:pusion-core-macro-majority-vote-combiner}}\label{\detokenize{pusion.core.macro_majority_vote_combiner:mamv-cref}}\label{\detokenize{pusion.core.macro_majority_vote_combiner::doc}}\index{module@\spxentry{module}!pusion.core.macro\_majority\_vote\_combiner@\spxentry{pusion.core.macro\_majority\_vote\_combiner}}\index{pusion.core.macro\_majority\_vote\_combiner@\spxentry{pusion.core.macro\_majority\_vote\_combiner}!module@\spxentry{module}}\index{MacroMajorityVoteCombiner (class in pusion.core.macro\_majority\_vote\_combiner)@\spxentry{MacroMajorityVoteCombiner}\spxextra{class in pusion.core.macro\_majority\_vote\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.macro_majority_vote_combiner:pusion.core.macro_majority_vote_combiner.MacroMajorityVoteCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.macro\_majority\_vote\_combiner.}}\sphinxbfcode{\sphinxupquote{MacroMajorityVoteCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.UtilityBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.UtilityBasedCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.macro_majority_vote_combiner:pusion.core.macro_majority_vote_combiner.MacroMajorityVoteCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MacroMajorityVoteCombiner}}}}} (MAMV) is based on a variation of the general majority vote method.
The fusion consists of a decision vector which is given by the majority of the classifiers in the ensemble for a
sample. MAMV does not consider outputs for each individual class (macro).
\index{combine() (pusion.core.macro\_majority\_vote\_combiner.MacroMajorityVoteCombiner method)@\spxentry{combine()}\spxextra{pusion.core.macro\_majority\_vote\_combiner.MacroMajorityVoteCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.macro_majority_vote_combiner:pusion.core.macro_majority_vote_combiner.MacroMajorityVoteCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by majority voting across all classifiers considering the most common classification
assignment (macro). Only crisp classification outputs are supported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp class assignments obtained by MAMV. Axis 0 represents samples and
axis 1 the class labels which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.maximum\_likelihood\_combiner}
\label{\detokenize{pusion.core.maximum_likelihood_combiner:module-pusion.core.maximum_likelihood_combiner}}\label{\detokenize{pusion.core.maximum_likelihood_combiner:pusion-core-maximum-likelihood-combiner}}\label{\detokenize{pusion.core.maximum_likelihood_combiner:mle-cref}}\label{\detokenize{pusion.core.maximum_likelihood_combiner::doc}}\index{module@\spxentry{module}!pusion.core.maximum\_likelihood\_combiner@\spxentry{pusion.core.maximum\_likelihood\_combiner}}\index{pusion.core.maximum\_likelihood\_combiner@\spxentry{pusion.core.maximum\_likelihood\_combiner}!module@\spxentry{module}}\index{MaximumLikelihoodCombiner (class in pusion.core.maximum\_likelihood\_combiner)@\spxentry{MaximumLikelihoodCombiner}\spxextra{class in pusion.core.maximum\_likelihood\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.MaximumLikelihoodCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.maximum\_likelihood\_combiner.}}\sphinxbfcode{\sphinxupquote{MaximumLikelihoodCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.TrainableCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.MaximumLikelihoodCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MaximumLikelihoodCombiner}}}}} (MLE) is a combiner that estimates the parameters \(\mu\) (sample means)
and \(\sigma\) (sample variances) of the Gaussian probability density function for each class \(\omega\).
Multiple decision outputs for a sample are converted into a new feature space.

\sphinxAtStartPar
The fusion is performed by evaluating the class conditional density
\begin{equation*}
\begin{split}p(x|\omega) = \frac{1}{\sigma \sqrt{2 \pi}}
    exp\left({-\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^2}\right).\end{split}
\end{equation*}
\sphinxAtStartPar
of a transformed sample \(x\) for each available class \(\omega\), respectively. The class with the highest
likelihood is considered as winner and thus forms the decision fusion.
\index{train() (pusion.core.maximum\_likelihood\_combiner.MaximumLikelihoodCombiner method)@\spxentry{train()}\spxextra{pusion.core.maximum\_likelihood\_combiner.MaximumLikelihoodCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.MaximumLikelihoodCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Maximum Likelihood combiner model by calculating the parameters of gaussian normal distribution
(i.e. means and variances) from the given decision outputs and true class assignments.
Both continuous and crisp classification outputs are supported. This procedure transforms decision outputs
into a new feature space.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.maximum\_likelihood\_combiner.MaximumLikelihoodCombiner method)@\spxentry{combine()}\spxextra{pusion.core.maximum\_likelihood\_combiner.MaximumLikelihoodCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.MaximumLikelihoodCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by the Maximum Likelihood method. This procedure involves evaluating the class
conditional density as described above. Both continuous and crisp classification outputs are supported.
Combining requires a trained {\hyperref[\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.MaximumLikelihoodCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MaximumLikelihoodCombiner}}}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of either crisp or continuous class assignments which represents fused
decisions obtained by MLE. Axis 0 represents samples and axis 1 the class assignments which are aligned
with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRMaximumLikelihoodCombiner (class in pusion.core.maximum\_likelihood\_combiner)@\spxentry{CRMaximumLikelihoodCombiner}\spxextra{class in pusion.core.maximum\_likelihood\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.CRMaximumLikelihoodCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.maximum\_likelihood\_combiner.}}\sphinxbfcode{\sphinxupquote{CRMaximumLikelihoodCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.MaximumLikelihoodCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.maximum\_likelihood\_combiner.MaximumLikelihoodCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.CRMaximumLikelihoodCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRMaximumLikelihoodCombiner}}}}} is a modification of {\hyperref[\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.MaximumLikelihoodCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MaximumLikelihoodCombiner}}}}} that
also supports complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed, such that all missing
classification assignments are considered as a constant, respectively. To use methods {\hyperref[\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.CRMaximumLikelihoodCombiner.train}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{train()}}}}} and
{\hyperref[\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.CRMaximumLikelihoodCombiner.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}} a coverage needs to be set first by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{train() (pusion.core.maximum\_likelihood\_combiner.CRMaximumLikelihoodCombiner method)@\spxentry{train()}\spxextra{pusion.core.maximum\_likelihood\_combiner.CRMaximumLikelihoodCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.CRMaximumLikelihoodCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Maximum Likelihood combiner model by calculating the parameters of gaussian normal distribution
(i.e. means and variances) from the given decision outputs and true class assignments.
Both continuous and crisp classification outputs are supported. This procedure transforms decision outputs
into a new feature space.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains either crisp or continuous
decision outputs per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.maximum\_likelihood\_combiner.CRMaximumLikelihoodCombiner method)@\spxentry{combine()}\spxextra{pusion.core.maximum\_likelihood\_combiner.CRMaximumLikelihoodCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.CRMaximumLikelihoodCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine decision outputs by the Maximum Likelihood method. This procedure involves evaluating the class
conditional density as described above. Both continuous and crisp classification outputs are supported.
Combining requires a trained {\hyperref[\detokenize{pusion.core.maximum_likelihood_combiner:pusion.core.maximum_likelihood_combiner.MaximumLikelihoodCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MaximumLikelihoodCombiner}}}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage. Each matrix corresponds to
one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp or continuous decision outputs per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of either crisp or continuous class assignments which represents fused
decisions obtained by MLE. Axis 0 represents samples and axis 1 the class assignments which are aligned
with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.micro\_majority\_vote\_combiner}
\label{\detokenize{pusion.core.micro_majority_vote_combiner:module-pusion.core.micro_majority_vote_combiner}}\label{\detokenize{pusion.core.micro_majority_vote_combiner:pusion-core-micro-majority-vote-combiner}}\label{\detokenize{pusion.core.micro_majority_vote_combiner:mimv-cref}}\label{\detokenize{pusion.core.micro_majority_vote_combiner::doc}}\index{module@\spxentry{module}!pusion.core.micro\_majority\_vote\_combiner@\spxentry{pusion.core.micro\_majority\_vote\_combiner}}\index{pusion.core.micro\_majority\_vote\_combiner@\spxentry{pusion.core.micro\_majority\_vote\_combiner}!module@\spxentry{module}}\index{MicroMajorityVoteCombiner (class in pusion.core.micro\_majority\_vote\_combiner)@\spxentry{MicroMajorityVoteCombiner}\spxextra{class in pusion.core.micro\_majority\_vote\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.micro_majority_vote_combiner:pusion.core.micro_majority_vote_combiner.MicroMajorityVoteCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.micro\_majority\_vote\_combiner.}}\sphinxbfcode{\sphinxupquote{MicroMajorityVoteCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.UtilityBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.UtilityBasedCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.micro_majority_vote_combiner:pusion.core.micro_majority_vote_combiner.MicroMajorityVoteCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MicroMajorityVoteCombiner}}}}} (MIMV) is based on a variation of the general majority vote method.
The fusion consists of a decision vector which results from the majority of assignments for each individual class.
\index{combine() (pusion.core.micro\_majority\_vote\_combiner.MicroMajorityVoteCombiner method)@\spxentry{combine()}\spxextra{pusion.core.micro\_majority\_vote\_combiner.MicroMajorityVoteCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.micro_majority_vote_combiner:pusion.core.micro_majority_vote_combiner.MicroMajorityVoteCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by MIMV across all classifiers per class (micro).
Only crisp classification outputs are supported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp class assignments obtained by MIMV. Axis 0 represents samples and
axis 1 the class labels which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRMicroMajorityVoteCombiner (class in pusion.core.micro\_majority\_vote\_combiner)@\spxentry{CRMicroMajorityVoteCombiner}\spxextra{class in pusion.core.micro\_majority\_vote\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.micro_majority_vote_combiner:pusion.core.micro_majority_vote_combiner.CRMicroMajorityVoteCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.micro\_majority\_vote\_combiner.}}\sphinxbfcode{\sphinxupquote{CRMicroMajorityVoteCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.micro_majority_vote_combiner:pusion.core.micro_majority_vote_combiner.MicroMajorityVoteCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.micro\_majority\_vote\_combiner.MicroMajorityVoteCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.micro_majority_vote_combiner:pusion.core.micro_majority_vote_combiner.CRMicroMajorityVoteCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRMicroMajorityVoteCombiner}}}}} is a modification of {\hyperref[\detokenize{pusion.core.micro_majority_vote_combiner:pusion.core.micro_majority_vote_combiner.MicroMajorityVoteCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MicroMajorityVoteCombiner}}}}} that
also supports complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed, such that all missing
classification assignments are considered as a constant, respectively. To call {\hyperref[\detokenize{pusion.core.micro_majority_vote_combiner:pusion.core.micro_majority_vote_combiner.CRMicroMajorityVoteCombiner.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}} a coverage needs to
be set first by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{combine() (pusion.core.micro\_majority\_vote\_combiner.CRMicroMajorityVoteCombiner method)@\spxentry{combine()}\spxextra{pusion.core.micro\_majority\_vote\_combiner.CRMicroMajorityVoteCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.micro_majority_vote_combiner:pusion.core.micro_majority_vote_combiner.CRMicroMajorityVoteCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine decision outputs by MIMV across all classifiers per class (micro).
Only crisp classification outputs are supported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp decision outputs
per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp class assignments which are obtained by MIMV. Axis 0 represents
samples and axis 1 all the class labels which are provided by the coverage.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.naive\_bayes\_combiner}
\label{\detokenize{pusion.core.naive_bayes_combiner:module-pusion.core.naive_bayes_combiner}}\label{\detokenize{pusion.core.naive_bayes_combiner:pusion-core-naive-bayes-combiner}}\label{\detokenize{pusion.core.naive_bayes_combiner:nb-cref}}\label{\detokenize{pusion.core.naive_bayes_combiner::doc}}\index{module@\spxentry{module}!pusion.core.naive\_bayes\_combiner@\spxentry{pusion.core.naive\_bayes\_combiner}}\index{pusion.core.naive\_bayes\_combiner@\spxentry{pusion.core.naive\_bayes\_combiner}!module@\spxentry{module}}\index{NaiveBayesCombiner (class in pusion.core.naive\_bayes\_combiner)@\spxentry{NaiveBayesCombiner}\spxextra{class in pusion.core.naive\_bayes\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.NaiveBayesCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.naive\_bayes\_combiner.}}\sphinxbfcode{\sphinxupquote{NaiveBayesCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.EvidenceBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.EvidenceBasedCombiner}}}}}, {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.TrainableCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.NaiveBayesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NaiveBayesCombiner}}}}} (NB) is a fusion method based on the Bayes theorem which is applied according to
Kuncheva %
\begin{footnote}[1]\sphinxAtStartFootnote
Ludmila I Kuncheva. \sphinxstyleemphasis{Combining pattern classifiers: methods and algorithms}. John Wiley \& Sons, 2014.
%
\end{footnote} and Titterington et al. %
\begin{footnote}[2]\sphinxAtStartFootnote
DM Titterington, GD Murray, LS Murray, DJ Spiegelhalter, AM Skene, JDF Habbema, and GJ Gelpke. Comparison of discrimination techniques applied to a complex data set of head injured patients. \sphinxstyleemphasis{Journal of the Royal Statistical Society: Series A (General)}, 144(2):145\textendash{}161, 1981.
%
\end{footnote}.
NB uses the confusion matrix as an evidence to calculate the a\sphinxhyphen{}priori probability and the bayesian belief value,
which in turn the decision fusion bases on. NB requires outputs from uncorrelated classifiers in the ensemble.

\sphinxAtStartPar

\index{set\_evidence() (pusion.core.naive\_bayes\_combiner.NaiveBayesCombiner method)@\spxentry{set\_evidence()}\spxextra{pusion.core.naive\_bayes\_combiner.NaiveBayesCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.NaiveBayesCombiner.set_evidence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_evidence}}}{\emph{\DUrole{n}{evidence}}}{}
\sphinxAtStartPar
Set the evidence given by confusion matrices calculated according to Kuncheva \sphinxfootnotemark[1]
for each ensemble classifier.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{evidence}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_classes, n\_classes)}.
Confusion matrices for each of \sphinxtitleref{n} classifiers.

\end{description}\end{quote}

\end{fulllineitems}

\index{train() (pusion.core.naive\_bayes\_combiner.NaiveBayesCombiner method)@\spxentry{train()}\spxextra{pusion.core.naive\_bayes\_combiner.NaiveBayesCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.NaiveBayesCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Naive Bayes combiner model by precalculating confusion matrices from given decision outputs and
true class assignments. Continuous decision outputs are converted into crisp multiclass assignments using
the MAX rule.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.naive\_bayes\_combiner.NaiveBayesCombiner method)@\spxentry{combine()}\spxextra{pusion.core.naive\_bayes\_combiner.NaiveBayesCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.NaiveBayesCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by using the Naive Bayes method.
Continuous decision outputs are converted to crisp multiclass predictions using the MAX rule.
Combining requires a trained {\hyperref[\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.NaiveBayesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NaiveBayesCombiner}}}}} or evidence set with \sphinxcode{\sphinxupquote{set\_evidence}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp class assignments which represents fused
decisions obtained by the maximum class support. Axis 0 represents samples and axis 1 the class
assignments which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRNaiveBayesCombiner (class in pusion.core.naive\_bayes\_combiner)@\spxentry{CRNaiveBayesCombiner}\spxextra{class in pusion.core.naive\_bayes\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.CRNaiveBayesCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.naive\_bayes\_combiner.}}\sphinxbfcode{\sphinxupquote{CRNaiveBayesCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.NaiveBayesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.naive\_bayes\_combiner.NaiveBayesCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.CRNaiveBayesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRNaiveBayesCombiner}}}}} is a modification of {\hyperref[\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.NaiveBayesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NaiveBayesCombiner}}}}} that
also supports complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed, such that all missing
classification assignments are considered as \sphinxtitleref{0}, respectively. To call {\hyperref[\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.CRNaiveBayesCombiner.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}} a coverage needs to be set
first by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{train() (pusion.core.naive\_bayes\_combiner.CRNaiveBayesCombiner method)@\spxentry{train()}\spxextra{pusion.core.naive\_bayes\_combiner.CRNaiveBayesCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.CRNaiveBayesCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Naive Bayes combiner model by precalculating confusion matrices from given decision outputs and
true class assignments. Continuous decision outputs are converted into crisp multiclass assignments using
the MAX rule.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains either crisp or continuous
decision outputs per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.naive\_bayes\_combiner.CRNaiveBayesCombiner method)@\spxentry{combine()}\spxextra{pusion.core.naive\_bayes\_combiner.CRNaiveBayesCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.CRNaiveBayesCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine decision outputs by using the Naive Bayes method.
Continuous decision outputs are converted to crisp multiclass predictions using the MAX rule.
Combining requires a trained {\hyperref[\detokenize{pusion.core.naive_bayes_combiner:pusion.core.naive_bayes_combiner.NaiveBayesCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NaiveBayesCombiner}}}}} or evidence set with \sphinxcode{\sphinxupquote{set\_evidence}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage. Each matrix corresponds to
one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp or continuous decision outputs per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp class assignments which represents fused decisions.
Axis 0 represents samples and axis 1 the class labels which are aligned with axis 2 in
\sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.neural\_network\_combiner}
\label{\detokenize{pusion.core.neural_network_combiner:module-pusion.core.neural_network_combiner}}\label{\detokenize{pusion.core.neural_network_combiner:pusion-core-neural-network-combiner}}\label{\detokenize{pusion.core.neural_network_combiner:nn-cref}}\label{\detokenize{pusion.core.neural_network_combiner::doc}}\index{module@\spxentry{module}!pusion.core.neural\_network\_combiner@\spxentry{pusion.core.neural\_network\_combiner}}\index{pusion.core.neural\_network\_combiner@\spxentry{pusion.core.neural\_network\_combiner}!module@\spxentry{module}}\index{NeuralNetworkCombiner (class in pusion.core.neural\_network\_combiner)@\spxentry{NeuralNetworkCombiner}\spxextra{class in pusion.core.neural\_network\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.NeuralNetworkCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.neural\_network\_combiner.}}\sphinxbfcode{\sphinxupquote{NeuralNetworkCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.TrainableCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.NeuralNetworkCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NeuralNetworkCombiner}}}}} (NN) is a learning and classifier\sphinxhyphen{}based combiner that converts multiple decision
outputs into new features, which in turn are used to train this combiner. The NN includes three hidden layers and a
dynamic number of neurons per layer, which is given by (\sphinxtitleref{n\_classifiers * n\_classes}).
\index{train() (pusion.core.neural\_network\_combiner.NeuralNetworkCombiner method)@\spxentry{train()}\spxextra{pusion.core.neural\_network\_combiner.NeuralNetworkCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.NeuralNetworkCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the NN combiner by fitting the Neural Network model with given decision outputs and
true class assignments. Both continuous and crisp classification outputs are supported.
This procedure transforms decision outputs into a new feature space.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.neural\_network\_combiner.NeuralNetworkCombiner method)@\spxentry{combine()}\spxextra{pusion.core.neural\_network\_combiner.NeuralNetworkCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.NeuralNetworkCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by the trained Neural Network model. Both continuous and crisp classification outputs
are supported. Combining requires a trained {\hyperref[\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.NeuralNetworkCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NeuralNetworkCombiner}}}}}. This procedure transforms decision
outputs into a new feature space.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of either crisp or continuous class assignments which represents fused
decisions obtained by NN. Axis 0 represents samples and axis 1 the class assignments which are aligned
with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRNeuralNetworkCombiner (class in pusion.core.neural\_network\_combiner)@\spxentry{CRNeuralNetworkCombiner}\spxextra{class in pusion.core.neural\_network\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.CRNeuralNetworkCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.neural\_network\_combiner.}}\sphinxbfcode{\sphinxupquote{CRNeuralNetworkCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.NeuralNetworkCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.neural\_network\_combiner.NeuralNetworkCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.CRNeuralNetworkCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRNeuralNetworkCombiner}}}}} is a modification of {\hyperref[\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.NeuralNetworkCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NeuralNetworkCombiner}}}}} that
also supports complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed, such that all missing
classification assignments are considered as a constant, respectively. To use methods {\hyperref[\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.CRNeuralNetworkCombiner.train}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{train()}}}}} and
{\hyperref[\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.CRNeuralNetworkCombiner.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}} a coverage needs to be set first by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{train() (pusion.core.neural\_network\_combiner.CRNeuralNetworkCombiner method)@\spxentry{train()}\spxextra{pusion.core.neural\_network\_combiner.CRNeuralNetworkCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.CRNeuralNetworkCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the NN combiner by fitting the Neural Network model with given decision outputs and
true class assignments. Both continuous and crisp classification outputs are supported.
This procedure transforms decision outputs into a new feature space.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains either crisp or continuous
decision outputs per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.neural\_network\_combiner.CRNeuralNetworkCombiner method)@\spxentry{combine()}\spxextra{pusion.core.neural\_network\_combiner.CRNeuralNetworkCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.CRNeuralNetworkCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine decision outputs by the trained Neural Network model. Both continuous and crisp classification outputs
are supported. Combining requires a trained {\hyperref[\detokenize{pusion.core.neural_network_combiner:pusion.core.neural_network_combiner.NeuralNetworkCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NeuralNetworkCombiner}}}}}. This procedure transforms decision
outputs into a new feature space.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage. Each matrix corresponds to
one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp or continuous decision outputs per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of either crisp or continuous class assignments which represents fused
decisions obtained by NN. Axis 0 represents samples and axis 1 the class assignments which are aligned
with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.simple\_average\_combiner}
\label{\detokenize{pusion.core.simple_average_combiner:module-pusion.core.simple_average_combiner}}\label{\detokenize{pusion.core.simple_average_combiner:pusion-core-simple-average-combiner}}\label{\detokenize{pusion.core.simple_average_combiner:avg-cref}}\label{\detokenize{pusion.core.simple_average_combiner::doc}}\index{module@\spxentry{module}!pusion.core.simple\_average\_combiner@\spxentry{pusion.core.simple\_average\_combiner}}\index{pusion.core.simple\_average\_combiner@\spxentry{pusion.core.simple\_average\_combiner}!module@\spxentry{module}}\index{SimpleAverageCombiner (class in pusion.core.simple\_average\_combiner)@\spxentry{SimpleAverageCombiner}\spxextra{class in pusion.core.simple\_average\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.simple_average_combiner:pusion.core.simple_average_combiner.SimpleAverageCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.simple\_average\_combiner.}}\sphinxbfcode{\sphinxupquote{SimpleAverageCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.UtilityBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.UtilityBasedCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.simple_average_combiner:pusion.core.simple_average_combiner.SimpleAverageCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SimpleAverageCombiner}}}}} (AVG) fuses decisions using the arithmetic mean rule.
The mean is calculated between decision vectors obtained by multiple ensemble classifiers for a sample.
The AVG combiner is unaware of the input problem (multiclass/multilabel) or the assignment type (crisp/continuous).
\index{combine() (pusion.core.simple\_average\_combiner.SimpleAverageCombiner method)@\spxentry{combine()}\spxextra{pusion.core.simple\_average\_combiner.SimpleAverageCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.simple_average_combiner:pusion.core.simple_average_combiner.SimpleAverageCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by averaging the class support of each classifier in the given ensemble.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp assignments which represents fused
decisions obtained by the AVG method. Axis 0 represents samples and axis 1 the class
assignments which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRSimpleAverageCombiner (class in pusion.core.simple\_average\_combiner)@\spxentry{CRSimpleAverageCombiner}\spxextra{class in pusion.core.simple\_average\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.simple_average_combiner:pusion.core.simple_average_combiner.CRSimpleAverageCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.simple\_average\_combiner.}}\sphinxbfcode{\sphinxupquote{CRSimpleAverageCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.simple_average_combiner:pusion.core.simple_average_combiner.SimpleAverageCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.simple\_average\_combiner.SimpleAverageCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.simple_average_combiner:pusion.core.simple_average_combiner.CRSimpleAverageCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRSimpleAverageCombiner}}}}} is a modification of {\hyperref[\detokenize{pusion.core.simple_average_combiner:pusion.core.simple_average_combiner.SimpleAverageCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SimpleAverageCombiner}}}}} that
also supports complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed to a unified
tensor representation supporting undefined class assignments. The mean is calculated only for assignments which
are defined. To call {\hyperref[\detokenize{pusion.core.simple_average_combiner:pusion.core.simple_average_combiner.CRSimpleAverageCombiner.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}} a coverage needs to be set first by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{combine() (pusion.core.simple\_average\_combiner.CRSimpleAverageCombiner method)@\spxentry{combine()}\spxextra{pusion.core.simple\_average\_combiner.CRSimpleAverageCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.simple_average_combiner:pusion.core.simple_average_combiner.CRSimpleAverageCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine decision outputs by averaging the defined class support of each classifier in the given ensemble.
Undefined class supports are excluded from averaging.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains either crisp or continuous
decision outputs per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp assignments which represents fused
decisions obtained by the AVG method. Axis 0 represents samples and axis 1 the class
assignments which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.core.weighted\_voting\_combiner}
\label{\detokenize{pusion.core.weighted_voting_combiner:module-pusion.core.weighted_voting_combiner}}\label{\detokenize{pusion.core.weighted_voting_combiner:pusion-core-weighted-voting-combiner}}\label{\detokenize{pusion.core.weighted_voting_combiner:wv-cref}}\label{\detokenize{pusion.core.weighted_voting_combiner::doc}}\index{module@\spxentry{module}!pusion.core.weighted\_voting\_combiner@\spxentry{pusion.core.weighted\_voting\_combiner}}\index{pusion.core.weighted\_voting\_combiner@\spxentry{pusion.core.weighted\_voting\_combiner}!module@\spxentry{module}}\index{WeightedVotingCombiner (class in pusion.core.weighted\_voting\_combiner)@\spxentry{WeightedVotingCombiner}\spxextra{class in pusion.core.weighted\_voting\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.WeightedVotingCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.weighted\_voting\_combiner.}}\sphinxbfcode{\sphinxupquote{WeightedVotingCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.EvidenceBasedCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.EvidenceBasedCombiner}}}}}, {\hyperref[\detokenize{pusion.core.combiner:pusion.core.combiner.TrainableCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.combiner.TrainableCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.WeightedVotingCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{WeightedVotingCombiner}}}}} (WV) is a weighted voting schema adopted from Kuncheva (eq. 4.43)
%
\begin{footnote}[1]\sphinxAtStartFootnote
Ludmila I Kuncheva. \sphinxstyleemphasis{Combining pattern classifiers: methods and algorithms}. John Wiley \& Sons, 2014.
%
\end{footnote}. Classifiers with better performance (i.e. accuracy) are given more
weight contributing to final decisions. Nevertheless, if classifiers of high performance disagree on a sample,
low performance classifiers may contribute to the final decision.

\sphinxAtStartPar

\index{set\_evidence() (pusion.core.weighted\_voting\_combiner.WeightedVotingCombiner method)@\spxentry{set\_evidence()}\spxextra{pusion.core.weighted\_voting\_combiner.WeightedVotingCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.WeightedVotingCombiner.set_evidence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_evidence}}}{\emph{\DUrole{n}{evidence}}}{}
\sphinxAtStartPar
Set the evidence given by confusion matrices calculated according to Kuncheva \sphinxfootnotemark[1]
for each ensemble classifier.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{evidence}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_classes, n\_classes)}.
Confusion matrices for each of \sphinxtitleref{n} classifiers.

\end{description}\end{quote}

\end{fulllineitems}

\index{train() (pusion.core.weighted\_voting\_combiner.WeightedVotingCombiner method)@\spxentry{train()}\spxextra{pusion.core.weighted\_voting\_combiner.WeightedVotingCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.WeightedVotingCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Weighted Voting combiner model by precalculating confusion matrices from given decision outputs and
true class assignments. Continuous decision outputs are converted into crisp multiclass assignments using
the MAX rule.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of either crisp or continuous class assignments which are considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.weighted\_voting\_combiner.WeightedVotingCombiner method)@\spxentry{combine()}\spxextra{pusion.core.weighted\_voting\_combiner.WeightedVotingCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.WeightedVotingCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Combine decision outputs by the weighted voting schema.
Classifiers with better performance (i.e. accuracy) are given more authority over final decisions.
Combining requires a trained {\hyperref[\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.WeightedVotingCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{WeightedVotingCombiner}}}}} or evidence set with \sphinxcode{\sphinxupquote{set\_evidence}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp class assignments which represents fused
decisions obtained by the maximum weighted class support. Axis 0 represents samples and axis 1 the class
assignments which are aligned with axis 2 in \sphinxcode{\sphinxupquote{decision\_tensor}} input tensor.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CRWeightedVotingCombiner (class in pusion.core.weighted\_voting\_combiner)@\spxentry{CRWeightedVotingCombiner}\spxextra{class in pusion.core.weighted\_voting\_combiner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.CRWeightedVotingCombiner}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.core.weighted\_voting\_combiner.}}\sphinxbfcode{\sphinxupquote{CRWeightedVotingCombiner}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.WeightedVotingCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pusion.core.weighted\_voting\_combiner.WeightedVotingCombiner}}}}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.CRWeightedVotingCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CRWeightedVotingCombiner}}}}} is a modification of {\hyperref[\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.WeightedVotingCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{WeightedVotingCombiner}}}}} that
also supports complementary\sphinxhyphen{}redundant decision outputs. Therefore the input is transformed to a unified
tensor representation supporting undefined class assignments. The mean is calculated only for assignments which
are defined. To call methods {\hyperref[\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.CRWeightedVotingCombiner.train}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{train()}}}}} and {\hyperref[\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.CRWeightedVotingCombiner.combine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{combine()}}}}}, a coverage needs to be set first
by the inherited \sphinxcode{\sphinxupquote{set\_coverage()}} method.
\index{train() (pusion.core.weighted\_voting\_combiner.CRWeightedVotingCombiner method)@\spxentry{train()}\spxextra{pusion.core.weighted\_voting\_combiner.CRWeightedVotingCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.CRWeightedVotingCombiner.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Train the Weighted Voting combiner model by precalculating confusion matrices from given decision outputs and
true class assignments. Continuous decision outputs are converted into crisp multiclass assignments using
the MAX rule.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp decision outputs
per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which is considered true for each sample during
the training procedure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{combine() (pusion.core.weighted\_voting\_combiner.CRWeightedVotingCombiner method)@\spxentry{combine()}\spxextra{pusion.core.weighted\_voting\_combiner.CRWeightedVotingCombiner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.CRWeightedVotingCombiner.combine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Combine decision outputs by the weighted voting schema.
Classifiers with better performance (i.e. accuracy) are given more authority over final decisions.
Combining requires a trained {\hyperref[\detokenize{pusion.core.weighted_voting_combiner:pusion.core.weighted_voting_combiner.WeightedVotingCombiner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{WeightedVotingCombiner}}}}} or evidence set with \sphinxcode{\sphinxupquote{set\_evidence}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{numpy.array} matrices, each of shape \sphinxtitleref{(n\_samples, n\_classes’)},
where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific and described by the coverage.
Each matrix corresponds to one of \sphinxtitleref{n\_classifiers} classifiers and contains crisp decision outputs
per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A matrix (\sphinxtitleref{numpy.array}) of crisp class assignments which are obtained by the best representative class
for a certain classifier’s behaviour per sample. Axis 0 represents samples and axis 1 all the class
labels which are provided by the coverage.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{pusion.evaluation package}
\label{\detokenize{pusion.evaluation:pusion-evaluation-package}}\label{\detokenize{pusion.evaluation::doc}}

\subsection{pusion.evaluation.evaluation module}
\label{\detokenize{pusion.evaluation.evaluation:module-pusion.evaluation.evaluation}}\label{\detokenize{pusion.evaluation.evaluation:pusion-evaluation-evaluation-module}}\label{\detokenize{pusion.evaluation.evaluation:eval-cref}}\label{\detokenize{pusion.evaluation.evaluation::doc}}\index{module@\spxentry{module}!pusion.evaluation.evaluation@\spxentry{pusion.evaluation.evaluation}}\index{pusion.evaluation.evaluation@\spxentry{pusion.evaluation.evaluation}!module@\spxentry{module}}\index{Evaluation (class in pusion.evaluation.evaluation)@\spxentry{Evaluation}\spxextra{class in pusion.evaluation.evaluation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation.}}\sphinxbfcode{\sphinxupquote{Evaluation}}}{\emph{\DUrole{o}{*}\DUrole{n}{argv}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
{\hyperref[\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Evaluation}}}}} provides methods for evaluating decision outputs (i.e. combiners and classifiers) with different
problems and coverage types.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{argv}} \textendash{} Performance metric functions.

\end{description}\end{quote}
\index{evaluate() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{evaluate()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.evaluate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate}}}{\emph{\DUrole{n}{true\_assignments}}, \emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Evaluate the decision outputs with already set classification performance metrics.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This evaluation is only applicable on redundant multiclass or multilabel decision outputs.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered true for the evaluation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp decision outputs by different classifiers per sample.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_instances, n\_metrics)}. Performance matrix containing performance values
for each set instance row\sphinxhyphen{}wise and each set performance metric column\sphinxhyphen{}wise.

\end{description}\end{quote}

\end{fulllineitems}

\index{evaluate\_cr\_decision\_outputs() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{evaluate\_cr\_decision\_outputs()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.evaluate_cr_decision_outputs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate\_cr\_decision\_outputs}}}{\emph{\DUrole{n}{true\_assignments}}, \emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{coverage}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Evaluate complementary\sphinxhyphen{}redundant decision outputs with already set classification performance metrics.
The outputs of each classifier for each class is considered as a binary output and thus, the performance is
calculated class\sphinxhyphen{}wise and averaged across all classes, which are covered by individual classifiers.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This evaluation is applicable on complementary\sphinxhyphen{}redundant ensemble classifier outputs.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered true for the evaluation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{list} elements. Each inner list contains classes as integers covered by a
classifier, which is identified by the positional index of the respective list.
If none set, the coverage for fully redundant classification is chosen by default.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_instances, n\_metrics)}. Performance matrix containing performance values
for each set instance row\sphinxhyphen{}wise and each set performance metric column\sphinxhyphen{}wise.

\end{description}\end{quote}

\end{fulllineitems}

\index{evaluate\_cr\_multi\_combiner\_decision\_outputs() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{evaluate\_cr\_multi\_combiner\_decision\_outputs()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.evaluate_cr_multi_combiner_decision_outputs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate\_cr\_multi\_combiner\_decision\_outputs}}}{\emph{\DUrole{n}{true\_assignments}}, \emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Evaluate decision outputs of multiple CR combiners with already set classification performance metrics.
The evaluation is performed by {\hyperref[\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.evaluate_cr_decision_outputs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{evaluate\_cr\_decision\_outputs()}}}}} for each combiner.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered true for the evaluation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_combiners, n\_samples, n\_classes)}.
Tensor of crisp decision outputs by different combiners per sample.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_instances, n\_metrics)}. Performance matrix containing performance values
for each set instance row\sphinxhyphen{}wise and each set performance metric column\sphinxhyphen{}wise.

\end{description}\end{quote}

\end{fulllineitems}

\index{class\_wise\_mean\_score() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{class\_wise\_mean\_score()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.class_wise_mean_score}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\_wise\_mean\_score}}}{\emph{\DUrole{n}{true\_assignments}}, \emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{coverage}}, \emph{\DUrole{n}{metric}}}{}
\sphinxAtStartPar
Calculate the class\sphinxhyphen{}wise mean score with the given metric for the given classification outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered true for the evaluation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{list} elements. Each inner list contains classes as integers covered by a
classifier, which is identified by the positional index of the respective list.
If none set, the coverage for fully redundant classification is chosen by default.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{metric}} \textendash{} The score metric.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classes,)}. The mean score per class across all classifiers.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_report() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{get\_report()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.get_report}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_report}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
A summary \sphinxtitleref{Report} of performed evaluations including all involved instances and performance metrics.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_runtime\_report() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{get\_runtime\_report()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.get_runtime_report}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_runtime\_report}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
A summary \sphinxtitleref{Report} of train and combine runtimes for all involved instances.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_instances() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{get\_instances()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.get_instances}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_instances}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
A \sphinxtitleref{list} of instances (i.e. combiner or classifiers) been evaluated.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_metrics() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{get\_metrics()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.get_metrics}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_metrics}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
A \sphinxtitleref{list} of performance metrics been used for evaluation.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_performance\_matrix() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{get\_performance\_matrix()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.get_performance_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_performance\_matrix}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_instances, n\_metrics)}. Performance matrix containing performance values
for each set instance row\sphinxhyphen{}wise and each set performance metric column\sphinxhyphen{}wise.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_runtime\_matrix() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{get\_runtime\_matrix()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.get_runtime_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_runtime\_matrix}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_instances, 2)}. Runtime matrix containing runtimes
for each set instance row\sphinxhyphen{}wise. The column at index \sphinxtitleref{0} describes train times and the column at index
\sphinxtitleref{1} describes combine times.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_top\_n\_instances() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{get\_top\_n\_instances()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.get_top_n_instances}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_top\_n\_instances}}}{\emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{metric}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Retrieve top \sphinxtitleref{n} best instances according to the given \sphinxtitleref{metric} in a sorted order.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} \textendash{} \sphinxtitleref{integer}. Number of instances to be retrieved. If unset, all instances are retrieved.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{metric}} \textendash{} The metric all instances are sorted by. If unset, the first metric is used.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Evaluated top \sphinxtitleref{n} instances.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_top\_instances() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{get\_top\_instances()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.get_top_instances}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_top\_instances}}}{\emph{\DUrole{n}{metric}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Retrieve best performing instances according to the given \sphinxtitleref{metric}.
Multiple instances may be returned having the identical best performance score.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{metric}} \textendash{} The metric all instances were evaluated with. If unset, the first metric is used.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Evaluated top instances according to their performance.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_instance\_performance\_tuples() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{get\_instance\_performance\_tuples()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.get_instance_performance_tuples}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_instance\_performance\_tuples}}}{\emph{\DUrole{n}{metric}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Retrieve (instance, performance) tuples created for to the given \sphinxtitleref{metric}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{metric}} \textendash{} The metric all instances are evaluated by. If unset, the first set metric is used.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{list} of (instance, performance) tuples.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_metrics() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{set\_metrics()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.set_metrics}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_metrics}}}{\emph{\DUrole{o}{*}\DUrole{n}{argv}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{argv}} \textendash{} Performance metric functions.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_instances() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{set\_instances()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.set_instances}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_instances}}}{\emph{\DUrole{n}{instances}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{instances}} \textendash{} An instance or a \sphinxtitleref{list} of instances to be evaluated, e.g. classifiers or combiners.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_runtimes() (pusion.evaluation.evaluation.Evaluation method)@\spxentry{set\_runtimes()}\spxextra{pusion.evaluation.evaluation.Evaluation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation:pusion.evaluation.evaluation.Evaluation.set_runtimes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_runtimes}}}{\emph{\DUrole{n}{runtimes}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{runtimes}} \textendash{} A \sphinxtitleref{tuple} of two lists of tuples describing the train and combine runtimes respectively.
Each runtime list is aligned with the list of set instances.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.evaluation.evaluation\_metrics module}
\label{\detokenize{pusion.evaluation.evaluation_metrics:module-pusion.evaluation.evaluation_metrics}}\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion-evaluation-evaluation-metrics-module}}\label{\detokenize{pusion.evaluation.evaluation_metrics::doc}}\index{module@\spxentry{module}!pusion.evaluation.evaluation\_metrics@\spxentry{pusion.evaluation.evaluation\_metrics}}\index{pusion.evaluation.evaluation\_metrics@\spxentry{pusion.evaluation.evaluation\_metrics}!module@\spxentry{module}}\index{multi\_label\_brier\_score\_micro() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_brier\_score\_micro()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_brier_score_micro}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_brier\_score\_micro}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Calculate the brier score for multi\sphinxhyphen{}label problems according to Brier 1950
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The micro brier score.

\end{fulllineitems}

\index{multi\_label\_brier\_score() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_brier\_score()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_brier_score}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_brier\_score}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
\sphinxAtStartPar
Calculate the brier score for multiclass problems according to Brier 1950
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The brier score.

\end{fulllineitems}

\index{multiclass\_brier\_score() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_brier\_score()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_brier_score}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_brier\_score}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
\sphinxAtStartPar
Calculate the brier score for multi\sphinxhyphen{}label problems according to Brier 1950
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The brier score.

\end{fulllineitems}

\index{far() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{far()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.far}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{far}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{pos\_normal\_class}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{0}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Calculate the false alarm rate for multiclass and multi\sphinxhyphen{}label problems.
FAR = (number of normal class samples incorrectly classified)/(number of all normal class samples) * 100
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:param pos\_normal\_class: the position of the ‘normal class’ in :param y\_true and :param y\_pred. Default is \sphinxtitleref{0}
:return: The false alarm rate.

\end{fulllineitems}

\index{multiclass\_fdr() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_fdr()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_fdr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_fdr}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
fault detection rate = (\# correctly classified faulty samples) / (\# all faulty samples) * 100
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The fault detection rate.

\end{fulllineitems}

\index{multilabel\_subset\_fdr() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multilabel\_subset\_fdr()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multilabel_subset_fdr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multilabel\_subset\_fdr}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
fault detection rate = (\# correctly classified faulty samples) / (\# all faulty samples) * 100
In multilabel classification, the function considers the faulty subset, i. e., if the entire set
of predicted faulty labels for a sample strictly match with the true set of faulty labels.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The fault detection rate.

\end{fulllineitems}

\index{multilabel\_minor\_fdr() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multilabel\_minor\_fdr()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multilabel_minor_fdr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multilabel\_minor\_fdr}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
fault detection rate = (\# correctly classified faulty samples) / (\# all faulty samples) * 100
In multilabel classification, the function considers the faulty subset, i. e., if the entire set
of predicted faulty labels for a sample strictly match with the true set of faulty labels.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The fault detection rate.

\end{fulllineitems}

\index{multiclass\_weighted\_precision() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_weighted\_precision()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_weighted_precision}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_weighted\_precision}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Calculate the precision for a multiclass problem with a \sphinxtitleref{weighted} average.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)}. Predicted labels or class assignments.
:return: The precision score.

\end{fulllineitems}

\index{multi\_label\_weighted\_precision() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_weighted\_precision()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_weighted_precision}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_weighted\_precision}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Calculate the precision for a multi\sphinxhyphen{}label problem with a \sphinxtitleref{weighted} average.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The precision score.

\end{fulllineitems}

\index{multiclass\_class\_wise\_precision() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_class\_wise\_precision()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_class_wise_precision}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_class\_wise\_precision}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Calculate the precision for a multiclass problem with average \sphinxtitleref{None}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The precision score.

\end{fulllineitems}

\index{multi\_label\_class\_wise\_precision() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_class\_wise\_precision()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_class_wise_precision}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_class\_wise\_precision}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Calculate the precision for a multi\sphinxhyphen{}label problem with average \sphinxtitleref{None}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The precision score.

\end{fulllineitems}

\index{multiclass\_recall() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_recall()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_recall}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_recall}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Calculate the recall for a multiclass problem with average \sphinxtitleref{weighted}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)}. Predicted labels or class assignments.
:return: The recall score.

\end{fulllineitems}

\index{multi\_label\_recall() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_recall()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_recall}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_recall}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Calculate the recall for a multi\sphinxhyphen{}label problem with average \sphinxtitleref{weighted}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The recall score.

\end{fulllineitems}

\index{multiclass\_class\_wise\_recall() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_class\_wise\_recall()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_class_wise_recall}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_class\_wise\_recall}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Calculate the recall for a multiclass problem with average \sphinxtitleref{None}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: Sequence of recall scores (for each class).

\end{fulllineitems}

\index{multi\_label\_class\_wise\_recall() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_class\_wise\_recall()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_class_wise_recall}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_class\_wise\_recall}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Calculate the recall for a multi\sphinxhyphen{}label problem with average \sphinxtitleref{None}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: Sequence of recall scores (for each class).

\end{fulllineitems}

\index{multiclass\_weighted\_scikit\_auc\_roc\_score() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_weighted\_scikit\_auc\_roc\_score()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_weighted_scikit_auc_roc_score}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_weighted\_scikit\_auc\_roc\_score}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Compute the scikit auc roc score for a multi\sphinxhyphen{}label problem with average \sphinxtitleref{weighted}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The auc roc score.

\end{fulllineitems}

\index{multi\_label\_weighted\_pytorch\_auc\_roc\_score() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_weighted\_pytorch\_auc\_roc\_score()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_weighted_pytorch_auc_roc_score}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_weighted\_pytorch\_auc\_roc\_score}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Compute the pytorch auc roc score for a multi\sphinxhyphen{}label problem with average \sphinxtitleref{weighted}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The auc roc score.

\end{fulllineitems}

\index{multi\_label\_pytorch\_auc\_roc\_score() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_pytorch\_auc\_roc\_score()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_pytorch_auc_roc_score}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_pytorch\_auc\_roc\_score}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
\sphinxAtStartPar
Compute the pytorch auc roc score for a multi\sphinxhyphen{}label problem with average \sphinxtitleref{None}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The auc roc score.

\end{fulllineitems}

\index{multiclass\_class\_wise\_avg\_precision() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_class\_wise\_avg\_precision()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_class_wise_avg_precision}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_class\_wise\_avg\_precision}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
\sphinxAtStartPar
Compute the class wise precision for a multiclass problem with average \sphinxtitleref{None}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The precision score.

\end{fulllineitems}

\index{multiclass\_weighted\_avg\_precision() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_weighted\_avg\_precision()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_weighted_avg_precision}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_weighted\_avg\_precision}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Compute the precision for a multiclass problem with average \sphinxtitleref{weighted}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The precision score.

\end{fulllineitems}

\index{multiclass\_auc\_precision\_recall\_curve() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_auc\_precision\_recall\_curve()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_auc_precision_recall_curve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_auc\_precision\_recall\_curve}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
\sphinxAtStartPar
Compute the class wise auc precision recall curve for a multiclass problem.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The aggregated auc precision recall curve class wise.

\end{fulllineitems}

\index{multiclass\_weighted\_pytorch\_auc\_roc() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_weighted\_pytorch\_auc\_roc()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_weighted_pytorch_auc_roc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_weighted\_pytorch\_auc\_roc}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Compute the pytorch auc roc for a multiclass problem with average \sphinxtitleref{weighted}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The auc roc score.

\end{fulllineitems}

\index{multiclass\_pytorch\_auc\_roc() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_pytorch\_auc\_roc()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_pytorch_auc_roc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_pytorch\_auc\_roc}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
\sphinxAtStartPar
Compute the pytorch auc roc for a multiclass problem with average \sphinxtitleref{None}.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The auc roc score.

\end{fulllineitems}

\index{multi\_label\_ranking\_avg\_precision\_score() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_ranking\_avg\_precision\_score()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_ranking_avg_precision_score}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_ranking\_avg\_precision\_score}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Compute the label ranking based average precision score for a multi\sphinxhyphen{}label problem.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The precision score.

\end{fulllineitems}

\index{multi\_label\_ranking\_loss() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_ranking\_loss()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_ranking_loss}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_ranking\_loss}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Compute the label ranking loss for a multi\sphinxhyphen{}label problem.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The precision score.
:return: The loss.

\end{fulllineitems}

\index{multi\_label\_normalized\_discounted\_cumulative\_gain() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_normalized\_discounted\_cumulative\_gain()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_normalized_discounted_cumulative_gain}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_normalized\_discounted\_cumulative\_gain}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Compute the normalized discounted cumulative gain for a multi\sphinxhyphen{}label problem.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The gain.

\end{fulllineitems}

\index{multiclass\_top\_1\_accuracy() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_top\_1\_accuracy()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_top_1_accuracy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_top\_1\_accuracy}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Compute the top\sphinxhyphen{}1 accuracy for a multiclass problem.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The accuracy score.

\end{fulllineitems}

\index{multiclass\_top\_3\_accuracy() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_top\_3\_accuracy()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_top_3_accuracy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_top\_3\_accuracy}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Compute the top\sphinxhyphen{}3 accuracy for a multiclass problem.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The accuracy score.

\end{fulllineitems}

\index{multiclass\_top\_5\_accuracy() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_top\_5\_accuracy()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_top_5_accuracy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_top\_5\_accuracy}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Compute the top\sphinxhyphen{}5 accuracy for a multiclass problem.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape (n\_samples, n\_classes)\textasciigrave{}. Predicted labels or class assignments.
:return: The accuracy score.

\end{fulllineitems}

\index{multiclass\_log\_loss() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multiclass\_log\_loss()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multiclass_log_loss}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multiclass\_log\_loss}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
The logarithmic loss for a multiclass problem.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The loss.

\end{fulllineitems}

\index{multi\_label\_log\_loss() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{multi\_label\_log\_loss()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.multi_label_log_loss}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{multi\_label\_log\_loss}}}{\emph{\DUrole{n}{y\_true}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{y\_pred}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
The logarithmic loss for a multi\sphinxhyphen{}label problem.
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: The loss.

\end{fulllineitems}

\index{micro\_precision() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{micro\_precision()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.micro_precision}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{micro\_precision}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the micro precision, i.e. TP / (TP + FP).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The micro precision.

\end{description}\end{quote}

\end{fulllineitems}

\index{micro\_recall() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{micro\_recall()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.micro_recall}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{micro\_recall}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the micro recall, i.e.  TP / (TP + FN).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The micro recall.

\end{description}\end{quote}

\end{fulllineitems}

\index{micro\_f1() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{micro\_f1()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.micro_f1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{micro\_f1}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the micro F1\sphinxhyphen{}score, i.e. 2 * (Precision * Recall) / (Precision + Recall).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The micro F1\sphinxhyphen{}score.

\end{description}\end{quote}

\end{fulllineitems}

\index{micro\_f2() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{micro\_f2()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.micro_f2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{micro\_f2}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the micro F2\sphinxhyphen{}score (beta=2).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The micro F2\sphinxhyphen{}score.

\end{description}\end{quote}

\end{fulllineitems}

\index{micro\_jaccard() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{micro\_jaccard()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.micro_jaccard}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{micro\_jaccard}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the micro Jaccard\sphinxhyphen{}score, i.e. TP / (TP + FP + FN).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The micro Jaccard\sphinxhyphen{}score.

\end{description}\end{quote}

\end{fulllineitems}

\index{macro\_precision() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{macro\_precision()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.macro_precision}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{macro\_precision}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the macro precision, i.e. TP / (TP + FP).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The macro precision.

\end{description}\end{quote}

\end{fulllineitems}

\index{macro\_recall() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{macro\_recall()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.macro_recall}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{macro\_recall}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the macro recall, i.e.  TP / (TP + FN).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The macro recall.

\end{description}\end{quote}

\end{fulllineitems}

\index{macro\_f1() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{macro\_f1()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.macro_f1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{macro\_f1}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the macro F1\sphinxhyphen{}score, i.e. 2 * (Precision * Recall) / (Precision + Recall).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The macro F1\sphinxhyphen{}score.

\end{description}\end{quote}

\end{fulllineitems}

\index{weighted\_f1() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{weighted\_f1()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.weighted_f1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{weighted\_f1}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the macro F1\sphinxhyphen{}score, i.e. 2 * (Precision * Recall) / (Precision + Recall), weighted by the class support.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The weighted macro F1\sphinxhyphen{}score.

\end{description}\end{quote}

\end{fulllineitems}

\index{macro\_f2() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{macro\_f2()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.macro_f2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{macro\_f2}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the macro F2\sphinxhyphen{}score (beta=2).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The macro F2\sphinxhyphen{}score.

\end{description}\end{quote}

\end{fulllineitems}

\index{macro\_jaccard() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{macro\_jaccard()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.macro_jaccard}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{macro\_jaccard}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the macro Jaccard\sphinxhyphen{}score, i.e. TP / (TP + FP + FN).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The macro Jaccard\sphinxhyphen{}score.

\end{description}\end{quote}

\end{fulllineitems}

\index{weighted\_jaccard() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{weighted\_jaccard()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.weighted_jaccard}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{weighted\_jaccard}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the Jaccard\sphinxhyphen{}score for each label, and find their average, weighted by support, i. e., the number of true instances of each label instance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The macro Jaccard\sphinxhyphen{}score.

\end{description}\end{quote}

\end{fulllineitems}

\index{accuracy() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{accuracy()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.accuracy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{accuracy}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the accuracy, i.e. (TP + TN) / (TP + FP + FN + TN).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Accuracy.

\end{description}\end{quote}

\end{fulllineitems}

\index{error\_rate() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{error\_rate()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.error_rate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{error\_rate}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the error rate, i. e. error\_rate = 1\sphinxhyphen{}accuracy
:param y\_true: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.
:param y\_pred: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or class assignments.
:return: Error Rate of typ \sphinxtitleref{float}

\end{fulllineitems}

\index{balanced\_multiclass\_accuracy() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{balanced\_multiclass\_accuracy()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.balanced_multiclass_accuracy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{balanced\_multiclass\_accuracy}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the balanced accuracy, i.e. (Precision + Recall) / 2.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Accuracy.

\end{description}\end{quote}

\end{fulllineitems}

\index{mean\_multilabel\_confusion\_matrix() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{mean\_multilabel\_confusion\_matrix()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.mean_multilabel_confusion_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{mean\_multilabel\_confusion\_matrix}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the normalized mean confusion matrix across all classes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classes, n\_classes)}. Normalized mean confusion matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{mean\_confidence() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{mean\_confidence()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.mean_confidence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{mean\_confidence}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the mean confidence for continuous multiclass and multilabel classification outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Predicted class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Mean confidence.

\end{description}\end{quote}

\end{fulllineitems}

\index{hamming() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{hamming()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.hamming}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{hamming}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the average Hamming Loss.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Average Hamming Loss.

\end{description}\end{quote}

\end{fulllineitems}

\index{log() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{log()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.log}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{log}}}{\emph{\DUrole{n}{y\_true}}, \emph{\DUrole{n}{y\_pred}}}{}
\sphinxAtStartPar
Calculate the Logistic Loss.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. True labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_pred}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Predicted labels or
class assignments.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Logistic Loss.

\end{description}\end{quote}

\end{fulllineitems}

\index{cohens\_kappa() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{cohens\_kappa()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.cohens_kappa}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{cohens\_kappa}}}{\emph{\DUrole{n}{y1}}, \emph{\DUrole{n}{y2}}, \emph{\DUrole{n}{labels}}}{}
\sphinxAtStartPar
Calculate the Cohen’s Kappa annotator agreement score according to %
\begin{footnote}[1]\sphinxAtStartFootnote
Jacob Cohen. A coefficient of agreement for nominal scales. \sphinxstyleemphasis{Educational and psychological measurement}, 20(1):37\textendash{}46, 1960.
%
\end{footnote}.

\sphinxAtStartPar

\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y1}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y2}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} or \sphinxtitleref{(n\_samples, n\_classes)}. Labels or class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{labels}} \textendash{} \sphinxtitleref{list} of all possible labels.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Cohen’s Kappa score.

\end{description}\end{quote}

\end{fulllineitems}

\index{pairwise\_cohens\_kappa() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{pairwise\_cohens\_kappa()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.pairwise_cohens_kappa}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{pairwise\_cohens\_kappa}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Calculate the average of pairwise Cohen’s Kappa scores over all multiclass decision outputs.
E.g., for 3 classifiers \sphinxtitleref{(0,1,2)}, the agreement score is calculated for classifier tuples \sphinxtitleref{(0,1)}, \sphinxtitleref{(0,2)} and
\sphinxtitleref{(1,2)}. These scores are then averaged over all 3 classifiers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp multiclass decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Pairwise (averages) Cohen’s Kappa score.

\end{description}\end{quote}

\end{fulllineitems}

\index{correlation() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{correlation()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.correlation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{correlation}}}{\emph{\DUrole{n}{y1}}, \emph{\DUrole{n}{y2}}, \emph{\DUrole{n}{y\_true}}}{}
\sphinxAtStartPar
Calculate the correlation score for decision outputs of two classifiers according to Kuncheva
%
\begin{footnote}[2]\sphinxAtStartFootnote
Ludmila I Kuncheva. \sphinxstyleemphasis{Combining pattern classifiers: methods and algorithms}. John Wiley \& Sons, 2014.
%
\end{footnote}.

\sphinxAtStartPar

\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y1}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the first classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y2}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the second classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Correlation score.

\end{description}\end{quote}

\end{fulllineitems}

\index{q\_statistic() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{q\_statistic()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.q_statistic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{q\_statistic}}}{\emph{\DUrole{n}{y1}}, \emph{\DUrole{n}{y2}}, \emph{\DUrole{n}{y\_true}}}{}
\sphinxAtStartPar
Calculate the Q statistic score for decision outputs of two classifiers according to Yule
%
\begin{footnote}[3]\sphinxAtStartFootnote
G Udny Yule. On the association of attributes in statistics: with illustrations from the material of the childhood society, \&c. \sphinxstyleemphasis{Philosophical Transactions of the Royal Society of London Series A}, 194:257\textendash{}319, 1900.
%
\end{footnote}.

\sphinxAtStartPar

\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y1}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the first classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y2}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the second classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Correlation score.

\end{description}\end{quote}

\end{fulllineitems}

\index{kappa\_statistic() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{kappa\_statistic()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.kappa_statistic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{kappa\_statistic}}}{\emph{\DUrole{n}{y1}}, \emph{\DUrole{n}{y2}}, \emph{\DUrole{n}{y\_true}}}{}
\sphinxAtStartPar
Calculate the kappa score for decision outputs of two classifiers according to Kuncheva
\sphinxfootnotemark[2].
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y1}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the first classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y2}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the second classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Kappa score.

\end{description}\end{quote}

\end{fulllineitems}

\index{disagreement() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{disagreement()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.disagreement}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{disagreement}}}{\emph{\DUrole{n}{y1}}, \emph{\DUrole{n}{y2}}, \emph{\DUrole{n}{y\_true}}}{}
\sphinxAtStartPar
Calculate the disagreement for decision outputs of two classifiers, i.e. the percentage of samples which are
correctly classified by exactly one of the classifiers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y1}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the first classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y2}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the second classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Disagreement score.

\end{description}\end{quote}

\end{fulllineitems}

\index{double\_fault() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{double\_fault()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.double_fault}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{double\_fault}}}{\emph{\DUrole{n}{y1}}, \emph{\DUrole{n}{y2}}, \emph{\DUrole{n}{y\_true}}}{}
\sphinxAtStartPar
Calculate the double fault for decision outputs of two classifiers, i.e. the percentage of samples which are
misclassified by both classifiers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y1}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the first classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y2}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the second classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Double fault score.

\end{description}\end{quote}

\end{fulllineitems}

\index{abs\_correlation() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{abs\_correlation()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.abs_correlation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{abs\_correlation}}}{\emph{\DUrole{n}{y1}}, \emph{\DUrole{n}{y2}}, \emph{\DUrole{n}{y\_true}}}{}
\sphinxAtStartPar
Calculate the absolute correlation score for decision outputs of two classifiers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y1}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the first classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y2}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the second classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Correlation score.

\end{description}\end{quote}

\end{fulllineitems}

\index{abs\_q\_statistic() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{abs\_q\_statistic()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.abs_q_statistic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{abs\_q\_statistic}}}{\emph{\DUrole{n}{y1}}, \emph{\DUrole{n}{y2}}, \emph{\DUrole{n}{y\_true}}}{}
\sphinxAtStartPar
Calculate the absolute Q statistic score for decision outputs of two classifiers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y1}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the first classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y2}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Crisp multiclass decision outputs by the second classifier.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y\_true}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Correlation score.

\end{description}\end{quote}

\end{fulllineitems}

\index{pairwise\_correlation() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{pairwise\_correlation()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.pairwise_correlation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{pairwise\_correlation}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Calculate the average of the pairwise absolute correlation scores over all decision outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp multiclass decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Pairwise correlation score.

\end{description}\end{quote}

\end{fulllineitems}

\index{pairwise\_q\_statistic() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{pairwise\_q\_statistic()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.pairwise_q_statistic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{pairwise\_q\_statistic}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Calculate the average of the pairwise absolute Q\sphinxhyphen{}statistic scores over all decision outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp multiclass decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Pairwise correlation score.

\end{description}\end{quote}

\end{fulllineitems}

\index{pairwise\_kappa\_statistic() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{pairwise\_kappa\_statistic()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.pairwise_kappa_statistic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{pairwise\_kappa\_statistic}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Calculate the average of pairwise Kappa scores over all decision outputs.
Multilabel class assignments are transformed to equivalent multiclass class assignments.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp multiclass decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Pairwise kappa score.

\end{description}\end{quote}

\end{fulllineitems}

\index{pairwise\_disagreement() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{pairwise\_disagreement()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.pairwise_disagreement}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{pairwise\_disagreement}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Calculate the average of pairwise disagreement scores over all decision outputs.
Multilabel class assignments are transformed to equivalent multiclass class assignments.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp multiclass decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Pairwise disagreement score.

\end{description}\end{quote}

\end{fulllineitems}

\index{pairwise\_double\_fault() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{pairwise\_double\_fault()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.pairwise_double_fault}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{pairwise\_double\_fault}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Calculate the average of pairwise double fault scores over all decision outputs.
Multilabel class assignments are transformed to equivalent multiclass class assignments.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp multiclass decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered as true.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Pairwise double fault score.

\end{description}\end{quote}

\end{fulllineitems}

\index{pairwise\_euclidean\_distance() (in module pusion.evaluation.evaluation\_metrics)@\spxentry{pairwise\_euclidean\_distance()}\spxextra{in module pusion.evaluation.evaluation\_metrics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.evaluation.evaluation_metrics:pusion.evaluation.evaluation_metrics.pairwise_euclidean_distance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.evaluation.evaluation\_metrics.}}\sphinxbfcode{\sphinxupquote{pairwise\_euclidean\_distance}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Calculate the average of pairwise euclidean distance between decision matrices for the given classifiers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp multiclass decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Pairwise euclidean distance.

\end{description}\end{quote}

\end{fulllineitems}



\section{pusion.model package}
\label{\detokenize{pusion.model:pusion-model-package}}\label{\detokenize{pusion.model::doc}}

\subsection{pusion.model.configuration module}
\label{\detokenize{pusion.model.configuration:module-pusion.model.configuration}}\label{\detokenize{pusion.model.configuration:pusion-model-configuration-module}}\label{\detokenize{pusion.model.configuration::doc}}\index{module@\spxentry{module}!pusion.model.configuration@\spxentry{pusion.model.configuration}}\index{pusion.model.configuration@\spxentry{pusion.model.configuration}!module@\spxentry{module}}\index{Configuration (class in pusion.model.configuration)@\spxentry{Configuration}\spxextra{class in pusion.model.configuration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.model.configuration:pusion.model.configuration.Configuration}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.model.configuration.}}\sphinxbfcode{\sphinxupquote{Configuration}}}{\emph{\DUrole{n}{method}}, \emph{\DUrole{n}{problem}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}GENERIC\textquotesingle{}}}, \emph{\DUrole{n}{assignment\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}GENERIC\textquotesingle{}}}, \emph{\DUrole{n}{coverage\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}GENERIC\textquotesingle{}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
The {\hyperref[\detokenize{pusion.model.configuration:pusion.model.configuration.Configuration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Configuration}}}}} forms the main parameter of the decision fusion framework. Based on this, the framework
is able to check the compatibility of a respective decision fusion method to the given decision outputs.
A configuration may be defined by the user or auto\sphinxhyphen{}detected by the framework.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{method}} \textendash{} An explicit method provided by the framework which should be applied on the input data set.
See \sphinxtitleref{pusion.Method} for possible options.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{problem}} \textendash{} Input problem type. See \sphinxtitleref{pusion.util.constants.Problem} for possible options.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{assignment\_type}} \textendash{} The class assignment describes memberships to each individual class for a sample.
A class assignment type is either crisp or continuous. Crisp assignments are equivalent to labels and
continuous assignments represent probabilities for each class being true.
See \sphinxtitleref{pusion.util.constants.AssignmentType} for possible options.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage\_type}} \textendash{} The classification coverage states for each input classifier, which classes it is able to
decide. A classifier ensemble may yield a redundant, complementary or complementary\sphinxhyphen{}redundant coverage.
See \sphinxtitleref{pusion.util.constants.CoverageType} for possible options.

\end{itemize}

\end{description}\end{quote}
\index{get\_tuple() (pusion.model.configuration.Configuration method)@\spxentry{get\_tuple()}\spxextra{pusion.model.configuration.Configuration method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.model.configuration:pusion.model.configuration.Configuration.get_tuple}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_tuple}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
A \sphinxtitleref{tuple} of method, problem, assignment type and coverage type.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_pac() (pusion.model.configuration.Configuration method)@\spxentry{get\_pac()}\spxextra{pusion.model.configuration.Configuration method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.model.configuration:pusion.model.configuration.Configuration.get_pac}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_pac}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
A \sphinxtitleref{tuple} of problem, assignment type and coverage type. This tuple is also referred to as PAC.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pusion.model.report module}
\label{\detokenize{pusion.model.report:module-pusion.model.report}}\label{\detokenize{pusion.model.report:pusion-model-report-module}}\label{\detokenize{pusion.model.report::doc}}\index{module@\spxentry{module}!pusion.model.report@\spxentry{pusion.model.report}}\index{pusion.model.report@\spxentry{pusion.model.report}!module@\spxentry{module}}\index{Report (class in pusion.model.report)@\spxentry{Report}\spxextra{class in pusion.model.report}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.model.report:pusion.model.report.Report}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pusion.model.report.}}\sphinxbfcode{\sphinxupquote{Report}}}{\emph{\DUrole{n}{performance\_matrix}}, \emph{\DUrole{n}{instances}}, \emph{\DUrole{n}{metrics}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
{\hyperref[\detokenize{pusion.model.report:pusion.model.report.Report}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Report}}}}} is a string representation of the performance matrix retrieved by \sphinxcode{\sphinxupquote{Evaluation}} methods.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{performance\_matrix}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_instances, n\_metrics)}. Performance matrix containing
performance values for each set instance row\sphinxhyphen{}wise and each set performance metric column\sphinxhyphen{}wise.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{instances}} \textendash{} \sphinxtitleref{list} of instances been evaluated which is aligned with the performance\_matrix on axis \sphinxtitleref{0}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{metrics}} \textendash{} \sphinxtitleref{list} of metric functions which is aligned with the performance\_matrix on axis \sphinxtitleref{1}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{pusion.util package}
\label{\detokenize{pusion.util:pusion-util-package}}\label{\detokenize{pusion.util::doc}}

\subsection{pusion.util.generator module}
\label{\detokenize{pusion.util.generator:module-pusion.util.generator}}\label{\detokenize{pusion.util.generator:pusion-util-generator-module}}\label{\detokenize{pusion.util.generator:generator-cref}}\label{\detokenize{pusion.util.generator::doc}}\index{module@\spxentry{module}!pusion.util.generator@\spxentry{pusion.util.generator}}\index{pusion.util.generator@\spxentry{pusion.util.generator}!module@\spxentry{module}}\index{generate\_multiclass\_ensemble\_classification\_outputs() (in module pusion.util.generator)@\spxentry{generate\_multiclass\_ensemble\_classification\_outputs()}\spxextra{in module pusion.util.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.generator:pusion.util.generator.generate_multiclass_ensemble_classification_outputs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.generator.}}\sphinxbfcode{\sphinxupquote{generate\_multiclass\_ensemble\_classification\_outputs}}}{\emph{\DUrole{n}{classifiers}}, \emph{\DUrole{n}{n\_classes}}, \emph{\DUrole{n}{n\_samples}}, \emph{\DUrole{n}{continuous\_out}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{parallelize}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Generate random multiclass, crisp and redundant classification outputs (assignments) for the given ensemble of
classifiers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{classifiers}} \textendash{} Classifiers used to generate classification outputs.
These need to implement \sphinxtitleref{fit} and \sphinxtitleref{predict} methods according to classifiers provided by \sphinxtitleref{sklearn}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_classes}} \textendash{} \sphinxtitleref{integer}. Number of classes, predictions are made for.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} \textendash{} \sphinxtitleref{integer}. Number of samples.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parallelize}} \textendash{} If \sphinxtitleref{True}, all classifiers are trained in parallel. Otherwise they are trained in sequence.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{continuous\_out}} \textendash{} If \sphinxtitleref{True}, class assignments in \sphinxtitleref{y\_ensemble\_valid} and \sphinxtitleref{y\_ensemble\_test} are given as
probabilities. Default value is \sphinxtitleref{False}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{tuple} of:
\sphinxhyphen{} \sphinxtitleref{y\_ensemble\_valid}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Ensemble decision output matrix for
as a validation dataset.
\sphinxhyphen{} \sphinxtitleref{y\_valid}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True class assignments for the validation.
\sphinxhyphen{} \sphinxtitleref{y\_ensemble\_test}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Ensemble decision output matrix for
as a test dataset.
\sphinxhyphen{} \sphinxtitleref{y\_test}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True class assignments for the test.

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_multiclass\_cr\_ensemble\_classification\_outputs() (in module pusion.util.generator)@\spxentry{generate\_multiclass\_cr\_ensemble\_classification\_outputs()}\spxextra{in module pusion.util.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.generator:pusion.util.generator.generate_multiclass_cr_ensemble_classification_outputs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.generator.}}\sphinxbfcode{\sphinxupquote{generate\_multiclass\_cr\_ensemble\_classification\_outputs}}}{\emph{\DUrole{n}{classifiers}}, \emph{\DUrole{n}{n\_classes}}, \emph{\DUrole{n}{n\_samples}}, \emph{\DUrole{n}{coverage}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{continuous\_out}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{parallelize}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Generate random multiclass, crisp and complementary\sphinxhyphen{}redundant classification outputs (assignments) for the given
ensemble of classifiers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{classifiers}} \textendash{} Classifiers used to generate classification outputs.
These need to implement \sphinxtitleref{fit} and \sphinxtitleref{predict} methods according to classifiers provided by \sphinxtitleref{sklearn}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_classes}} \textendash{} \sphinxtitleref{integer}. Number of classes, predictions are made for.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} \textendash{} \sphinxtitleref{integer}. Number of samples.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{list} elements. Each inner list contains classes as integers covered by a classifier,
which is identified by the positional index of the respective list.
If unset, redundant classification outputs are retrieved.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{continuous\_out}} \textendash{} If \sphinxtitleref{True}, class assignments in \sphinxtitleref{y\_ensemble\_valid} and \sphinxtitleref{y\_ensemble\_test} are given as
probabilities. Default value is \sphinxtitleref{False}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parallelize}} \textendash{} If \sphinxtitleref{True}, all classifiers are trained in parallel. Otherwise they are trained in sequence.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{tuple} of:
\sphinxhyphen{} \sphinxtitleref{y\_ensemble\_valid}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Ensemble decision output matrix for
as a validation dataset.
\sphinxhyphen{} \sphinxtitleref{y\_valid}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True class assignments for the validation.
\sphinxhyphen{} \sphinxtitleref{y\_ensemble\_test}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Ensemble decision output matrix for
as a test dataset.
\sphinxhyphen{} \sphinxtitleref{y\_test}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True class assignments for the test.

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_multilabel\_ensemble\_classification\_outputs() (in module pusion.util.generator)@\spxentry{generate\_multilabel\_ensemble\_classification\_outputs()}\spxextra{in module pusion.util.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.generator:pusion.util.generator.generate_multilabel_ensemble_classification_outputs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.generator.}}\sphinxbfcode{\sphinxupquote{generate\_multilabel\_ensemble\_classification\_outputs}}}{\emph{\DUrole{n}{classifiers}}, \emph{\DUrole{n}{n\_classes}}, \emph{\DUrole{n}{n\_samples}}, \emph{\DUrole{n}{continuous\_out}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{parallelize}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Generate random multilabel crisp classification outputs (assignments) for the given ensemble of classifiers with
the normal class included at index \sphinxtitleref{0}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{classifiers}} \textendash{} Classifiers used to generate classification outputs.
These need to implement \sphinxtitleref{fit} and \sphinxtitleref{predict} methods according to classifiers provided by \sphinxtitleref{sklearn}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_classes}} \textendash{} \sphinxtitleref{integer}. Number of classes, predictions are made for with the normal class included.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} \textendash{} \sphinxtitleref{integer}. Number of samples.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{continuous\_out}} \textendash{} If \sphinxtitleref{True}, class assignments in \sphinxtitleref{y\_ensemble\_valid} and \sphinxtitleref{y\_ensemble\_test} are given as
probabilities. Default value is \sphinxtitleref{False}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parallelize}} \textendash{} If \sphinxtitleref{True}, all classifiers are trained in parallel. Otherwise they are trained in sequence.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{tuple} of:
\sphinxhyphen{} \sphinxtitleref{y\_ensemble\_valid}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Ensemble decision output matrix for
as a validation dataset.
\sphinxhyphen{} \sphinxtitleref{y\_valid}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True class assignments for the validation.
\sphinxhyphen{} \sphinxtitleref{y\_ensemble\_test}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Ensemble decision output matrix for
as a test dataset.
\sphinxhyphen{} \sphinxtitleref{y\_test}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True class assignments for the test.

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_multilabel\_cr\_ensemble\_classification\_outputs() (in module pusion.util.generator)@\spxentry{generate\_multilabel\_cr\_ensemble\_classification\_outputs()}\spxextra{in module pusion.util.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.generator:pusion.util.generator.generate_multilabel_cr_ensemble_classification_outputs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.generator.}}\sphinxbfcode{\sphinxupquote{generate\_multilabel\_cr\_ensemble\_classification\_outputs}}}{\emph{\DUrole{n}{classifiers}}, \emph{\DUrole{n}{n\_classes}}, \emph{\DUrole{n}{n\_samples}}, \emph{\DUrole{n}{coverage}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{continuous\_out}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{parallelize}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Generate random multilabel, crisp and complementary\sphinxhyphen{}redundant classification outputs (assignments) for the given
ensemble of classifiers with the normal class included at index \sphinxtitleref{0}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{classifiers}} \textendash{} Classifiers used to generate classification outputs.
These need to implement \sphinxtitleref{fit} and \sphinxtitleref{predict} methods according to classifiers provided by \sphinxtitleref{sklearn}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_classes}} \textendash{} \sphinxtitleref{integer}. Number of classes, predictions are made for with the normal class included.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} \textendash{} \sphinxtitleref{integer}. Number of samples.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{list} elements. Each inner list contains classes as integers covered by a classifier,
which is identified by the positional index of the respective list.
If unset, redundant classification outputs are retrieved.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{continuous\_out}} \textendash{} If \sphinxtitleref{True}, class assignments in \sphinxtitleref{y\_ensemble\_valid} and \sphinxtitleref{y\_ensemble\_test} are given as
probabilities. Default value is \sphinxtitleref{False}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parallelize}} \textendash{} If \sphinxtitleref{True}, all classifiers are trained in parallel. Otherwise they are trained in sequence.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{tuple} of:
\sphinxhyphen{} \sphinxtitleref{y\_ensemble\_valid}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Ensemble decision output matrix for
as a validation dataset.
\sphinxhyphen{} \sphinxtitleref{y\_valid}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True class assignments for the validation.
\sphinxhyphen{} \sphinxtitleref{y\_ensemble\_test}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Ensemble decision output matrix for
as a test dataset.
\sphinxhyphen{} \sphinxtitleref{y\_test}: \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. True class assignments for the test.

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_multiclass\_confusion\_matrices() (in module pusion.util.generator)@\spxentry{generate\_multiclass\_confusion\_matrices()}\spxextra{in module pusion.util.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.generator:pusion.util.generator.generate_multiclass_confusion_matrices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.generator.}}\sphinxbfcode{\sphinxupquote{generate\_multiclass\_confusion\_matrices}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}}{}
\sphinxAtStartPar
Generate multiclass confusion matrices out of the given decision tensor and true assignments.
Continuous outputs are converted to multiclass assignments using the MAX rule.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered true for calculating confusion matrices.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_samples)}. Confusion matrices per classifier.

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_multilabel\_cr\_confusion\_matrices() (in module pusion.util.generator)@\spxentry{generate\_multilabel\_cr\_confusion\_matrices()}\spxextra{in module pusion.util.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.generator:pusion.util.generator.generate_multilabel_cr_confusion_matrices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.generator.}}\sphinxbfcode{\sphinxupquote{generate\_multilabel\_cr\_confusion\_matrices}}}{\emph{\DUrole{n}{decision\_outputs}}, \emph{\DUrole{n}{true\_assignments}}, \emph{\DUrole{n}{coverage}}}{}
\sphinxAtStartPar
Generate multilabel confusion matrices for complementary\sphinxhyphen{}redundant multilabel classification outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of crisp class assignments which are considered true for calculating confusion matrices.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{list} elements. Each inner list contains classes as integers covered by a classifier,
which is identified by the positional index of the respective list.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
List of multilabel confusion matrices.

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_classification\_coverage() (in module pusion.util.generator)@\spxentry{generate\_classification\_coverage()}\spxextra{in module pusion.util.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.generator:pusion.util.generator.generate_classification_coverage}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.generator.}}\sphinxbfcode{\sphinxupquote{generate\_classification\_coverage}}}{\emph{\DUrole{n}{n\_classifiers}}, \emph{\DUrole{n}{n\_classes}}, \emph{\DUrole{n}{overlap}}, \emph{\DUrole{n}{normal\_class}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Generate random complementary redundant class indices for each classifier \sphinxtitleref{0..(n\_classifiers\sphinxhyphen{}1)}.
The coverage is drawn from normal distribution for all classifiers.
However, it is guaranteed that each classifier covers at least one class regardless of the distribution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_classifiers}} \textendash{} Number of classifiers representing the classifier \sphinxtitleref{0..(n\_classifiers\sphinxhyphen{}1)}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_classes}} \textendash{} Number of classes representing the class label \sphinxtitleref{0..(n\_classes\sphinxhyphen{}1)}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{overlap}} \textendash{} Indicator between \sphinxtitleref{0} and \sphinxtitleref{1} for overall classifier overlapping in terms of classes.
If \sphinxtitleref{0}, only complementary class indices are obtained.
If \sphinxtitleref{1}, the overlapping is fully redundant.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normal\_class}} \textendash{} If \sphinxtitleref{True}, a class for the normal state is included for all classifiers as class index \sphinxtitleref{0}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{list} of \sphinxtitleref{list} elements. Each inner list contains classes as integers covered by a classifier,
which is identified by the positional index of the respective list.

\end{description}\end{quote}

\end{fulllineitems}

\index{shrink\_to\_coverage() (in module pusion.util.generator)@\spxentry{shrink\_to\_coverage()}\spxextra{in module pusion.util.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.generator:pusion.util.generator.shrink_to_coverage}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.generator.}}\sphinxbfcode{\sphinxupquote{shrink\_to\_coverage}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{coverage}}}{}
\sphinxAtStartPar
Shrink the given decision tensor to decision outputs according to the given coverage.
Assumption: the normal class is covered by each classifier at index \sphinxtitleref{0}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp multilabel decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coverage}} \textendash{} \sphinxtitleref{list} of \sphinxtitleref{list} elements. Each inner list contains classes as integers covered by a classifier,
which is identified by the positional index of the respective list.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{list} of \sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is
classifier\sphinxhyphen{}specific due to the coverage.

\end{description}\end{quote}

\end{fulllineitems}

\index{split\_into\_train\_and\_validation\_data() (in module pusion.util.generator)@\spxentry{split\_into\_train\_and\_validation\_data()}\spxextra{in module pusion.util.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.generator:pusion.util.generator.split_into_train_and_validation_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.generator.}}\sphinxbfcode{\sphinxupquote{split\_into\_train\_and\_validation\_data}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{true\_assignments}}, \emph{\DUrole{n}{validation\_size}\DUrole{o}{=}\DUrole{default_value}{0.5}}}{}
\sphinxAtStartPar
Split the decision outputs (tensor) from multiple classifiers as well as the true assignments randomly into train
and validation datasets.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{true\_assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}.
Matrix of true class assignments.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{validation\_size}} \textendash{} Proportion between \sphinxtitleref{0} and \sphinxtitleref{1} for the size of the validation data set.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{tuple} of
(1) \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples’, n\_classes)},
(2) \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples’)},
(3) \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples’’, n\_classes)},
(4) \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples’’)}, with \sphinxtitleref{n\_samples’} as the number of training
samples and \sphinxtitleref{n\_samples’’} as the number of validation samples.

\end{description}\end{quote}

\end{fulllineitems}



\subsection{pusion.util.transformer module}
\label{\detokenize{pusion.util.transformer:module-pusion.util.transformer}}\label{\detokenize{pusion.util.transformer:pusion-util-transformer-module}}\label{\detokenize{pusion.util.transformer:transformer-cref}}\label{\detokenize{pusion.util.transformer::doc}}\index{module@\spxentry{module}!pusion.util.transformer@\spxentry{pusion.util.transformer}}\index{pusion.util.transformer@\spxentry{pusion.util.transformer}!module@\spxentry{module}}\index{confusion\_matrices\_to\_accuracy\_vector() (in module pusion.util.transformer)@\spxentry{confusion\_matrices\_to\_accuracy\_vector()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.confusion_matrices_to_accuracy_vector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{confusion\_matrices\_to\_accuracy\_vector}}}{\emph{\DUrole{n}{confusion\_matrix\_tensor}}}{}
\sphinxAtStartPar
Convert confusion matrices of respective classification to an accuracy vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{confusion\_matrix\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_classes, n\_classes)}
Confusion matrices.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
One\sphinxhyphen{}dimensional \sphinxtitleref{numpy.array} of shape of length \sphinxtitleref{n\_classifiers} containing the accuracy for each confusion
matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{confusion\_matrix\_to\_accuracy() (in module pusion.util.transformer)@\spxentry{confusion\_matrix\_to\_accuracy()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.confusion_matrix_to_accuracy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{confusion\_matrix\_to\_accuracy}}}{\emph{\DUrole{n}{cm}}}{}
\sphinxAtStartPar
Calculate the accuracy out of the given confusion matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cm}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classes, n\_classes)}.
Confusion matrix.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The accuracy.

\end{description}\end{quote}

\end{fulllineitems}

\index{multilabel\_cr\_confusion\_matrices\_to\_avg\_accuracy() (in module pusion.util.transformer)@\spxentry{multilabel\_cr\_confusion\_matrices\_to\_avg\_accuracy()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.multilabel_cr_confusion_matrices_to_avg_accuracy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{multilabel\_cr\_confusion\_matrices\_to\_avg\_accuracy}}}{\emph{\DUrole{n}{label\_cms}}}{}
\sphinxAtStartPar
Calculate the average accuracy for the given confusion matrices generated from complementary redundant multilabel
output.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label\_cms}} \textendash{} \sphinxtitleref{list} of confusion matrices given as 2\sphinxhyphen{}dimensional \sphinxtitleref{numpy.array} respectively.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The average accuracy.

\end{description}\end{quote}

\end{fulllineitems}

\index{decision\_tensor\_to\_decision\_profiles() (in module pusion.util.transformer)@\spxentry{decision\_tensor\_to\_decision\_profiles()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.decision_tensor_to_decision_profiles}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{decision\_tensor\_to\_decision\_profiles}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Transform the given decision tensor to decision profiles for each respective sample.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of either crisp or continuous decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classifiers, n\_classes)}.
Decision profiles.

\end{description}\end{quote}

\end{fulllineitems}

\index{multilabel\_predictions\_to\_decisions() (in module pusion.util.transformer)@\spxentry{multilabel\_predictions\_to\_decisions()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.multilabel_predictions_to_decisions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{multilabel\_predictions\_to\_decisions}}}{\emph{\DUrole{n}{predictions}}, \emph{\DUrole{n}{threshold}\DUrole{o}{=}\DUrole{default_value}{0.5}}}{}
\sphinxAtStartPar
Transform a continuously valued tensor of multilabel decisions to crisp decision outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{predictions}} \textendash{} \sphinxtitleref{numpy.array} of any shape. Continuous predictions.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{threshold}} \textendash{} \sphinxtitleref{float}. A threshold value, based on which the crisp output is constructed.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of the same shape as \sphinxcode{\sphinxupquote{predictions}}. Crisp decision outputs.

\end{description}\end{quote}

\end{fulllineitems}

\index{multiclass\_predictions\_to\_decisions() (in module pusion.util.transformer)@\spxentry{multiclass\_predictions\_to\_decisions()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.multiclass_predictions_to_decisions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{multiclass\_predictions\_to\_decisions}}}{\emph{\DUrole{n}{predictions}}}{}
\sphinxAtStartPar
Transform a continuously valued matrix of multiclass decisions to crisp decision outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{predictions}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Continuous predictions.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of the same shape as \sphinxcode{\sphinxupquote{predictions}}. Crisp decision outputs.

\end{description}\end{quote}

\end{fulllineitems}

\index{multilabel\_prediction\_tensor\_to\_decision\_tensor() (in module pusion.util.transformer)@\spxentry{multilabel\_prediction\_tensor\_to\_decision\_tensor()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.multilabel_prediction_tensor_to_decision_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{multilabel\_prediction\_tensor\_to\_decision\_tensor}}}{\emph{\DUrole{n}{predictions}}}{}
\sphinxAtStartPar
Transform a continuously valued tensor of multilabel decisions to crisp decision outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{predictions}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}. Continuous predictions.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of the same shape as \sphinxcode{\sphinxupquote{predictions}}. Crisp decision outputs.

\end{description}\end{quote}

\end{fulllineitems}

\index{multiclass\_prediction\_tensor\_to\_decision\_tensor() (in module pusion.util.transformer)@\spxentry{multiclass\_prediction\_tensor\_to\_decision\_tensor()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.multiclass_prediction_tensor_to_decision_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{multiclass\_prediction\_tensor\_to\_decision\_tensor}}}{\emph{\DUrole{n}{predictions}}}{}
\sphinxAtStartPar
Transform a continuously valued tensor of multiclass decisions to crisp decision outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{predictions}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}. Continuous predictions.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of the same shape as \sphinxcode{\sphinxupquote{predictions}}. Crisp decision outputs.

\end{description}\end{quote}

\end{fulllineitems}

\index{decision\_tensor\_to\_configs() (in module pusion.util.transformer)@\spxentry{decision\_tensor\_to\_configs()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.decision_tensor_to_configs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{decision\_tensor\_to\_configs}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Transform decision outputs to decision configs. A decision config shows concatenated classification outputs of each
classifier per sample.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_outputs}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} or a \sphinxtitleref{list} of
\sphinxtitleref{numpy.array} elements of shape \sphinxtitleref{(n\_samples, n\_classes’)}, where \sphinxtitleref{n\_classes’} is classifier\sphinxhyphen{}specific
due to the coverage.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes*)}, \sphinxtitleref{n\_classes*} is the sum of all classes covered by
all classifiers.

\end{description}\end{quote}

\end{fulllineitems}

\index{multiclass\_assignments\_to\_labels() (in module pusion.util.transformer)@\spxentry{multiclass\_assignments\_to\_labels()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.multiclass_assignments_to_labels}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{multiclass\_assignments\_to\_labels}}}{\emph{\DUrole{n}{assignments}}}{}
\sphinxAtStartPar
Transform multiclass assignments to labels. A matrix of shape \sphinxtitleref{(n\_samples, n\_classes)} is converted to a vector
of shape \sphinxtitleref{(n\_samples,)}, with element\sphinxhyphen{}wise labels represented in integers from \sphinxtitleref{0} to \sphinxtitleref{n\_classes \sphinxhyphen{} 1}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{assignments}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Multiclass assignments.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} with an integer label per element.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform\_label\_tensor\_to\_class\_assignment\_tensor() (in module pusion.util.transformer)@\spxentry{transform\_label\_tensor\_to\_class\_assignment\_tensor()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.transform_label_tensor_to_class_assignment_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{transform\_label\_tensor\_to\_class\_assignment\_tensor}}}{\emph{\DUrole{n}{label\_tensor}}, \emph{\DUrole{n}{n\_classes}}}{}
\sphinxAtStartPar
Transform a label tensor of shape \sphinxtitleref{(n\_classifiers, n\_samples)} to the tensor of class assignments of shape
\sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}. A label is an integer between \sphinxtitleref{0} and \sphinxtitleref{n\_classes \sphinxhyphen{} 1}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples)}. Label tensor.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_classes}} \textendash{} Number of classes to be considered.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}. Class assignment tensor (decision tensor).

\end{description}\end{quote}

\end{fulllineitems}

\index{transform\_label\_vector\_to\_class\_assignment\_matrix() (in module pusion.util.transformer)@\spxentry{transform\_label\_vector\_to\_class\_assignment\_matrix()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.transform_label_vector_to_class_assignment_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{transform\_label\_vector\_to\_class\_assignment\_matrix}}}{\emph{\DUrole{n}{label\_vector}}, \emph{\DUrole{n}{n\_classes}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Transform labels to multiclass assignments. A vector of shape \sphinxtitleref{(n\_samples,)}, with element\sphinxhyphen{}wise labels is converted
to the assignment matrix of shape \sphinxtitleref{(n\_samples, n\_classes)}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label\_vector}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)} with an integer label per element.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_classes}} \textendash{} Number of classes to be considered.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Multiclass assignments.

\end{description}\end{quote}

\end{fulllineitems}

\index{class\_assignment\_tensor\_to\_label\_tensor() (in module pusion.util.transformer)@\spxentry{class\_assignment\_tensor\_to\_label\_tensor()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.class_assignment_tensor_to_label_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{class\_assignment\_tensor\_to\_label\_tensor}}}{\emph{\DUrole{n}{class\_assignment\_tensor}}}{}
\sphinxAtStartPar
Transform multiclass class assignments into a label tensor. A tensor of shape
\sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)} is converted into a tensor of shape \sphinxtitleref{(n\_classifiers, n\_samples)} holding the
class identifier (label) in each element.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{class\_assignment\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Class assignment tensor (decision tensor).

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples)}. Label tensor.

\end{description}\end{quote}

\end{fulllineitems}

\index{class\_assignment\_matrix\_to\_label\_vector() (in module pusion.util.transformer)@\spxentry{class\_assignment\_matrix\_to\_label\_vector()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.class_assignment_matrix_to_label_vector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{class\_assignment\_matrix\_to\_label\_vector}}}{\emph{\DUrole{n}{class\_assignment\_matrix}}}{}
\sphinxAtStartPar
Transform multiclass class assignments into a label vector. A matrix of shape
\sphinxtitleref{(n\_samples, n\_classes)} is converted into a vector of shape \sphinxtitleref{(n\_samples,)} holding the class identifier (label)
in each element.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{class\_assignment\_matrix}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Class assignment matrix
(decision matrix).

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples,)}. Label vector.

\end{description}\end{quote}

\end{fulllineitems}

\index{multilabel\_to\_multiclass\_assignments() (in module pusion.util.transformer)@\spxentry{multilabel\_to\_multiclass\_assignments()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.multilabel_to_multiclass_assignments}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{multilabel\_to\_multiclass\_assignments}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Transform the multilabel decision tensor to the equivalent multiclass decision tensor using the power set method.
The multilabel class assignments are considered as a binary number which represents a new class in the
multiclass decision space. E.g. the assignment to the classes \sphinxtitleref{0} and \sphinxtitleref{2} (\sphinxtitleref{{[}1,0,1{]}}) is converted to the class \sphinxtitleref{5},
which is one of the \sphinxtitleref{2\textasciicircum{}3} classes in the multiclass decision space.
This method is inverse to the \sphinxcode{\sphinxupquote{multiclass\_to\_multilabel\_assignments}} method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp multilabel decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, 2\textasciicircum{}n\_classes)}.
Tensor of crisp multiclass decision outputs by different classifiers per sample.

\end{description}\end{quote}

\end{fulllineitems}

\index{multiclass\_to\_multilabel\_assignments() (in module pusion.util.transformer)@\spxentry{multiclass\_to\_multilabel\_assignments()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.multiclass_to_multilabel_assignments}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{multiclass\_to\_multilabel\_assignments}}}{\emph{\DUrole{n}{decision\_tensor}}}{}
\sphinxAtStartPar
Transform the multiclass decision tensor to the equivalent multilabel decision tensor using the inverse
power set method. The multiclass assignment is considered as a decimal which is converted to a binary number, which
in turn represents the multilabel class assignment. E.g. the class assignment to the class \sphinxtitleref{3} \sphinxtitleref{({[}0,0,0,1{]})} is
converted to the multilabel class assignment \sphinxtitleref{{[}1,1{]}} (classes \sphinxtitleref{0} and \sphinxtitleref{1} in the multilabel decision space).
This method is inverse to the \sphinxcode{\sphinxupquote{multilabel\_to\_multiclass\_assignments}} method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of crisp multilabel decision outputs by different classifiers per sample.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, log\_2(n\_classes))}.
Tensor of crisp multiclass decision outputs by different classifiers per sample.

\end{description}\end{quote}

\end{fulllineitems}

\index{tensorize() (in module pusion.util.transformer)@\spxentry{tensorize()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.tensorize}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{tensorize}}}{\emph{\DUrole{n}{decision\_outputs}}}{}
\sphinxAtStartPar
Convert \sphinxtitleref{list} decision outputs to \sphinxtitleref{numpy.array} decision tensor, if possible.

\end{fulllineitems}

\index{intercept\_normal\_class() (in module pusion.util.transformer)@\spxentry{intercept\_normal\_class()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.intercept_normal_class}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{intercept\_normal\_class}}}{\emph{\DUrole{n}{y}}, \emph{\DUrole{n}{override}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Intercept the normal class for the given decision matrix, i.e. a normal class is assigned to each zero vector
class assignment. E.g. the assignment \sphinxtitleref{{[}0,0,0,0{]}} is transformed to \sphinxtitleref{{[}1,0,0,0{]}}, under the assumption that \sphinxtitleref{0}
is a normal class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)}. Matrix of decision outputs.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{override}} \textendash{} If \sphinxtitleref{true}, the class \sphinxtitleref{0} is assumed as a normal class. Otherwise a new class is prepended to
existing classes.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)} for \sphinxtitleref{override=False}.
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes + 1)} for \sphinxtitleref{override=True}.
Matrix of decision outputs with intercepted normal class.

\end{description}\end{quote}

\end{fulllineitems}

\index{intercept\_normal\_class\_in\_tensor() (in module pusion.util.transformer)@\spxentry{intercept\_normal\_class\_in\_tensor()}\spxextra{in module pusion.util.transformer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pusion.util.transformer:pusion.util.transformer.intercept_normal_class_in_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pusion.util.transformer.}}\sphinxbfcode{\sphinxupquote{intercept\_normal\_class\_in\_tensor}}}{\emph{\DUrole{n}{decision\_tensor}}, \emph{\DUrole{n}{override}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Intercept the normal class for the given decision matrix, i.e. a normal class is assigned to each zero vector
class assignment. E.g. the assignment \sphinxtitleref{{[}0,0,0,0{]}} is transformed to \sphinxtitleref{{[}1,0,0,0{]}}, under the assumption that \sphinxtitleref{0}
is a normal class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{decision\_tensor}} \textendash{} \sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_classifiers, n\_samples, n\_classes)}.
Tensor of decision outputs by different classifiers per sample.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{override}} \textendash{} If \sphinxtitleref{true}, the class \sphinxtitleref{0} is assumed as a normal class. Otherwise a new class is prepended to
existing classes.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes)} for \sphinxtitleref{override=False}.
\sphinxtitleref{numpy.array} of shape \sphinxtitleref{(n\_samples, n\_classes + 1)} for \sphinxtitleref{override=True}.
Matrix of decision outputs with intercepted normal class.

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Usage and Examples}
\label{\detokenize{usage_and_examples:usage-and-examples}}\label{\detokenize{usage_and_examples::doc}}

\section{A simple example}
\label{\detokenize{usage_and_examples:a-simple-example}}
\sphinxAtStartPar
The following code shows an illustrative and simple example of using pusion for decision outputs of three classifiers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pusion} \PYG{k}{as} \PYG{n+nn}{p}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} Create exemplary classification outputs (class assignments)}
\PYG{n}{classifier\PYGZus{}a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{classifier\PYGZus{}b} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{classifier\PYGZus{}c} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Create a numpy tensor}
\PYG{n}{ensemble\PYGZus{}out} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{classifier\PYGZus{}a}\PYG{p}{,} \PYG{n}{classifier\PYGZus{}b}\PYG{p}{,} \PYG{n}{classifier\PYGZus{}c}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initialize the general framework interface}
\PYG{n}{dp} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{DecisionProcessor}\PYG{p}{(}\PYG{n}{p}\PYG{o}{.}\PYG{n}{Configuration}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{n}{p}\PYG{o}{.}\PYG{n}{Method}\PYG{o}{.}\PYG{n}{MACRO\PYGZus{}MAJORITY\PYGZus{}VOTE}\PYG{p}{,}
                                         \PYG{n}{problem}\PYG{o}{=}\PYG{n}{p}\PYG{o}{.}\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{MULTI\PYGZus{}CLASS}\PYG{p}{,}
                                         \PYG{n}{assignment\PYGZus{}type}\PYG{o}{=}\PYG{n}{p}\PYG{o}{.}\PYG{n}{AssignmentType}\PYG{o}{.}\PYG{n}{CRISP}\PYG{p}{,}
                                         \PYG{n}{coverage\PYGZus{}type}\PYG{o}{=}\PYG{n}{p}\PYG{o}{.}\PYG{n}{CoverageType}\PYG{o}{.}\PYG{n}{REDUNDANT}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Fuse the ensemble classification outputs}
\PYG{n}{fused\PYGZus{}decisions} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{dp}\PYG{o}{.}\PYG{n}{combine}\PYG{p}{(}\PYG{n}{ensemble\PYGZus{}out}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fused\PYGZus{}decisions}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}\PYG{o}{[}\PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{1}\PYG{o}{]}
 \PYG{o}{[}\PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{0}\PYG{o}{]}
 \PYG{o}{[}\PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{0}\PYG{o}{]}\PYG{o}{]}
\end{sphinxVerbatim}


\section{A richer example}
\label{\detokenize{usage_and_examples:a-richer-example}}
\sphinxAtStartPar
In this example, an ensemble is created using \sphinxtitleref{sklearn}’s neural network classifiers.
The 200 classification outputs are split up into validation and test datasets.
\sphinxcode{\sphinxupquote{y\_ensemble\_valid}} and \sphinxcode{\sphinxupquote{y\_ensemble\_test}} holds the classification outputs of the whole ensemble, while
\sphinxcode{\sphinxupquote{y\_valid}} and \sphinxcode{\sphinxupquote{y\_test}} are representing true labels.
The validation datasets are used to train the \sphinxtitleref{DempsterShaferCombiner} combiner ({\hyperref[\detokenize{pusion.core.dempster_shafer_combiner:ds-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{DS}}}}), while the
final fusion is performed on the test dataset (without true labels).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pusion} \PYG{k}{as} \PYG{n+nn}{p}

\PYG{k+kn}{import} \PYG{n+nn}{sklearn}

\PYG{c+c1}{\PYGZsh{} Create an ensemble of 3 neural networks with different hyperparameters}
\PYG{n}{classifiers} \PYG{o}{=} \PYG{p}{[}
    \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{neural\PYGZus{}network}\PYG{o}{.}\PYG{n}{MLPClassifier}\PYG{p}{(}\PYG{n}{hidden\PYGZus{}layer\PYGZus{}sizes}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{neural\PYGZus{}network}\PYG{o}{.}\PYG{n}{MLPClassifier}\PYG{p}{(}\PYG{n}{hidden\PYGZus{}layer\PYGZus{}sizes}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{neural\PYGZus{}network}\PYG{o}{.}\PYG{n}{MLPClassifier}\PYG{p}{(}\PYG{n}{hidden\PYGZus{}layer\PYGZus{}sizes}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Generate samples for the ensemble}
\PYG{n}{y\PYGZus{}ensemble\PYGZus{}valid}\PYG{p}{,} \PYG{n}{y\PYGZus{}valid}\PYG{p}{,} \PYG{n}{y\PYGZus{}ensemble\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}test} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{generate\PYGZus{}multiclass\PYGZus{}ensemble\PYGZus{}classification\PYGZus{}outputs}\PYG{p}{(}
    \PYG{n}{classifiers}\PYG{o}{=}\PYG{n}{classifiers}\PYG{p}{,}
    \PYG{n}{n\PYGZus{}classes}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}
    \PYG{n}{n\PYGZus{}samples}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} User defined configuration}
\PYG{n}{conf} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{Configuration}\PYG{p}{(}
    \PYG{n}{method}\PYG{o}{=}\PYG{n}{p}\PYG{o}{.}\PYG{n}{Method}\PYG{o}{.}\PYG{n}{DEMPSTER\PYGZus{}SHAFER}\PYG{p}{,}
    \PYG{n}{problem}\PYG{o}{=}\PYG{n}{p}\PYG{o}{.}\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{MULTI\PYGZus{}CLASS}\PYG{p}{,}
    \PYG{n}{assignment\PYGZus{}type}\PYG{o}{=}\PYG{n}{p}\PYG{o}{.}\PYG{n}{AssignmentType}\PYG{o}{.}\PYG{n}{CRISP}\PYG{p}{,}
    \PYG{n}{coverage\PYGZus{}type}\PYG{o}{=}\PYG{n}{p}\PYG{o}{.}\PYG{n}{CoverageType}\PYG{o}{.}\PYG{n}{REDUNDANT}
\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initialize the general framework interface}
\PYG{n}{dp} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{DecisionProcessor}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Train the selected Dempster Shafer combiner with the validation dataset}
\PYG{n}{dp}\PYG{o}{.}\PYG{n}{train}\PYG{p}{(}\PYG{n}{y\PYGZus{}ensemble\PYGZus{}valid}\PYG{p}{,} \PYG{n}{y\PYGZus{}valid}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Fuse the ensemble classification outputs (test dataset)}
\PYG{n}{y\PYGZus{}comb} \PYG{o}{=} \PYG{n}{dp}\PYG{o}{.}\PYG{n}{combine}\PYG{p}{(}\PYG{n}{y\PYGZus{}ensemble\PYGZus{}test}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Evaluation}
\label{\detokenize{usage_and_examples:evaluation}}
\sphinxAtStartPar
In addition to the previous example, we are able to evaluate both, the ensemble and the combiner classification
performance using the evaluation methods provided by the framework.
The critical point for achieving a reasonable comparison is obviously the usage of the same test dataset
for the combiner as well as for the ensemble.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define classification performance metrics used for the evaluation}
\PYG{n}{eval\PYGZus{}metrics} \PYG{o}{=} \PYG{p}{[}
    \PYG{n}{p}\PYG{o}{.}\PYG{n}{PerformanceMetric}\PYG{o}{.}\PYG{n}{ACCURACY}\PYG{p}{,}
    \PYG{n}{p}\PYG{o}{.}\PYG{n}{PerformanceMetric}\PYG{o}{.}\PYG{n}{MICRO\PYGZus{}F1\PYGZus{}SCORE}\PYG{p}{,}
    \PYG{n}{p}\PYG{o}{.}\PYG{n}{PerformanceMetric}\PYG{o}{.}\PYG{n}{MICRO\PYGZus{}PRECISION}
\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{============= Ensemble ===============}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}classifiers} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{Evaluation}\PYG{p}{(}\PYG{o}{*}\PYG{n}{eval\PYGZus{}metrics}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}classifiers}\PYG{o}{.}\PYG{n}{set\PYGZus{}instances}\PYG{p}{(}\PYG{n}{classifiers}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}classifiers}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}ensemble\PYGZus{}test}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{eval\PYGZus{}classifiers}\PYG{o}{.}\PYG{n}{get\PYGZus{}report}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{============== Combiner ==============}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}combiner} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{Evaluation}\PYG{p}{(}\PYG{o}{*}\PYG{n}{eval\PYGZus{}metrics}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}combiner}\PYG{o}{.}\PYG{n}{set\PYGZus{}instances}\PYG{p}{(}\PYG{n}{dp}\PYG{o}{.}\PYG{n}{get\PYGZus{}combiner}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}combiner}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}comb}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{eval\PYGZus{}combiner}\PYG{o}{.}\PYG{n}{get\PYGZus{}report}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
============= Ensemble ===============
                                     accuracy     f1  precision
MLPClassifier [0]                       0.810  0.810      0.810
MLPClassifier [1]                       0.800  0.800      0.800
MLPClassifier [2]                       0.792  0.792      0.792
============== Combiner ==============
                                     accuracy     f1  precision
DempsterShaferCombiner                  0.816  0.816      0.816
\end{sphinxVerbatim}


\section{Auto Combiner}
\label{\detokenize{usage_and_examples:auto-combiner}}
\sphinxAtStartPar
The following code shows an exemplary usage and evaluation of the {\hyperref[\detokenize{pusion.auto.auto_combiner:ac-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{AutoCombiner}}}} specified in
the configuration.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dp} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{DecisionProcessor}\PYG{p}{(}\PYG{n}{p}\PYG{o}{.}\PYG{n}{Configuration}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{n}{p}\PYG{o}{.}\PYG{n}{Method}\PYG{o}{.}\PYG{n}{AUTO}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{dp}\PYG{o}{.}\PYG{n}{train}\PYG{p}{(}\PYG{n}{y\PYGZus{}ensemble\PYGZus{}valid}\PYG{p}{,} \PYG{n}{y\PYGZus{}valid}\PYG{p}{)}
\PYG{n}{y\PYGZus{}comb} \PYG{o}{=} \PYG{n}{dp}\PYG{o}{.}\PYG{n}{combine}\PYG{p}{(}\PYG{n}{y\PYGZus{}ensemble\PYGZus{}test}\PYG{p}{)}

\PYG{n}{eval\PYGZus{}combiner} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{Evaluation}\PYG{p}{(}\PYG{o}{*}\PYG{n}{eval\PYGZus{}metrics}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}combiner}\PYG{o}{.}\PYG{n}{set\PYGZus{}instances}\PYG{p}{(}\PYG{n}{dp}\PYG{o}{.}\PYG{n}{get\PYGZus{}combiner}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}combiner}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}comb}\PYG{p}{)}

\PYG{n}{dp}\PYG{o}{.}\PYG{n}{set\PYGZus{}evaluation}\PYG{p}{(}\PYG{n}{eval\PYGZus{}combiner}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dp}\PYG{o}{.}\PYG{n}{report}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
================================= AutoCombiner \PYGZhy{} Report ==================================
                   Problem: MULTI\PYGZus{}CLASS
           Assignment type: CRISP
             Coverage type: REDUNDANT
   Combiner type selection: UtilityBasedCombiner, TrainableCombiner
      Compatible combiners: CosineSimilarityCombiner, MacroMajorityVoteCombiner, MicroMajorityVoteCombiner, SimpleAverageCombiner, BehaviourKnowledgeSpaceCombiner, DecisionTemplatesCombiner, KNNCombiner, DempsterShaferCombiner, MaximumLikelihoodCombiner, NaiveBayesCombiner, NeuralNetworkCombiner, WeightedVotingCombiner
          Optimal combiner: CosineSimilarityCombiner
Classification performance:
                                     accuracy  micro\PYGZus{}f1  micro\PYGZus{}precision
AutoCombiner                            0.836     0.836            0.836
==========================================================================================
\end{sphinxVerbatim}


\section{Generic Combiner}
\label{\detokenize{usage_and_examples:generic-combiner}}
\sphinxAtStartPar
For the given data sets one could also use the {\hyperref[\detokenize{pusion.auto.generic_combiner:gc-cref}]{\sphinxcrossref{\DUrole{std,std-ref}{GenericCombiner}}}} to gain an overview over applicable
methods and their respective performances.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dp} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{DecisionProcessor}\PYG{p}{(}\PYG{n}{p}\PYG{o}{.}\PYG{n}{Configuration}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{n}{p}\PYG{o}{.}\PYG{n}{Method}\PYG{o}{.}\PYG{n}{GENERIC}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{dp}\PYG{o}{.}\PYG{n}{train}\PYG{p}{(}\PYG{n}{y\PYGZus{}ensemble\PYGZus{}valid}\PYG{p}{,} \PYG{n}{y\PYGZus{}valid}\PYG{p}{)}
\PYG{n}{dp}\PYG{o}{.}\PYG{n}{combine}\PYG{p}{(}\PYG{n}{y\PYGZus{}ensemble\PYGZus{}test}\PYG{p}{)}

\PYG{n}{eval\PYGZus{}combiner} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{Evaluation}\PYG{p}{(}\PYG{o}{*}\PYG{n}{eval\PYGZus{}metrics}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}combiner}\PYG{o}{.}\PYG{n}{set\PYGZus{}instances}\PYG{p}{(}\PYG{n}{dp}\PYG{o}{.}\PYG{n}{get\PYGZus{}combiners}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}combiner}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{dp}\PYG{o}{.}\PYG{n}{get\PYGZus{}multi\PYGZus{}combiner\PYGZus{}decision\PYGZus{}output}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{dp}\PYG{o}{.}\PYG{n}{set\PYGZus{}evaluation}\PYG{p}{(}\PYG{n}{eval\PYGZus{}combiner}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dp}\PYG{o}{.}\PYG{n}{report}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The \sphinxtitleref{DecisionProcessor} provides \sphinxcode{\sphinxupquote{get\_multi\_combiner\_decision\_output()}} to retrieve fused decisions from each
applicable combiner.
\end{sphinxadmonition}

\sphinxAtStartPar
Output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
================================ GenericCombiner \PYGZhy{} Report ================================
                   Problem: MULTI\PYGZus{}CLASS
           Assignment type: CRISP
             Coverage type: REDUNDANT
   Combiner type selection: UtilityBasedCombiner, TrainableCombiner
      Compatible combiners: CosineSimilarityCombiner, MacroMajorityVoteCombiner, MicroMajorityVoteCombiner, SimpleAverageCombiner, BehaviourKnowledgeSpaceCombiner, DecisionTemplatesCombiner, KNNCombiner, DempsterShaferCombiner, MaximumLikelihoodCombiner, NaiveBayesCombiner, NeuralNetworkCombiner, WeightedVotingCombiner
          Optimal combiner: WeightedVotingCombiner
Classification performance:
                                     accuracy  micro\PYGZus{}f1  micro\PYGZus{}precision
CosineSimilarityCombiner                0.836     0.836            0.836
MacroMajorityVoteCombiner               0.836     0.836            0.836
MicroMajorityVoteCombiner               0.836     0.836            0.836
SimpleAverageCombiner                   0.836     0.836            0.836
BehaviourKnowledgeSpaceCombiner         0.822     0.831            0.840
DecisionTemplatesCombiner               0.836     0.836            0.836
KNNCombiner                             0.826     0.836            0.846
DempsterShaferCombiner                  0.836     0.836            0.836
MaximumLikelihoodCombiner               0.834     0.834            0.834
NaiveBayesCombiner                      0.836     0.836            0.836
NeuralNetworkCombiner                   0.826     0.832            0.838
WeightedVotingCombiner                  0.836     0.836            0.836
==========================================================================================
\end{sphinxVerbatim}


\section{CR classification}
\label{\detokenize{usage_and_examples:cr-classification}}
\sphinxAtStartPar
In \sphinxtitleref{complementary\sphinxhyphen{}redundant} classification (CR), ensemble classifiers are not able to make predictions for all
available classes. They may complement each other or share some classes. In such cases, a \sphinxtitleref{coverage} needs to be
specified in order to use the framework properly. The coverage describes for each ensemble classifier, which classes
it is able to make predictions for. In pusion, it can be defined by a simple 2D list, e.g., \sphinxcode{\sphinxupquote{{[}{[}0,1{]}, {[}0,2,3{]}{]}}}, where
the first classifier is covering the classes \sphinxtitleref{0,1} while the second one covers \sphinxtitleref{0,2,3}.
The following code example shows how to generate and combine such complementary\sphinxhyphen{}redundant classification outputs.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pusion} \PYG{k}{as} \PYG{n+nn}{p}
\PYG{k+kn}{import} \PYG{n+nn}{sklearn}

\PYG{c+c1}{\PYGZsh{} Create an ensemble of 3 neural networks with different hyperparameters}
\PYG{n}{classifiers} \PYG{o}{=} \PYG{p}{[}
    \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{neural\PYGZus{}network}\PYG{o}{.}\PYG{n}{MLPClassifier}\PYG{p}{(}\PYG{n}{max\PYGZus{}iter}\PYG{o}{=}\PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}layer\PYGZus{}sizes}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{neural\PYGZus{}network}\PYG{o}{.}\PYG{n}{MLPClassifier}\PYG{p}{(}\PYG{n}{max\PYGZus{}iter}\PYG{o}{=}\PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}layer\PYGZus{}sizes}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{neural\PYGZus{}network}\PYG{o}{.}\PYG{n}{MLPClassifier}\PYG{p}{(}\PYG{n}{max\PYGZus{}iter}\PYG{o}{=}\PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}layer\PYGZus{}sizes}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Create a random complementary\PYGZhy{}redundant classification coverage with 60\PYGZpc{} overlap.}
\PYG{n}{coverage} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{generate\PYGZus{}classification\PYGZus{}coverage}\PYG{p}{(}\PYG{n}{n\PYGZus{}classifiers}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{n\PYGZus{}classes}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{overlap}\PYG{o}{=}\PYG{l+m+mf}{.6}\PYG{p}{,} \PYG{n}{normal\PYGZus{}class}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Generate samples for the complementary\PYGZhy{}redundant ensemble}
\PYG{n}{y\PYGZus{}ensemble\PYGZus{}valid}\PYG{p}{,} \PYG{n}{y\PYGZus{}valid}\PYG{p}{,} \PYG{n}{y\PYGZus{}ensemble\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}test} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{generate\PYGZus{}multilabel\PYGZus{}cr\PYGZus{}ensemble\PYGZus{}classification\PYGZus{}outputs}\PYG{p}{(}
    \PYG{n}{classifiers}\PYG{o}{=}\PYG{n}{classifiers}\PYG{p}{,}
    \PYG{n}{n\PYGZus{}classes}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}
    \PYG{n}{n\PYGZus{}samples}\PYG{o}{=}\PYG{l+m+mi}{2000}\PYG{p}{,}
    \PYG{n}{coverage}\PYG{o}{=}\PYG{n}{coverage}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initialize the general framework interface}
\PYG{n}{dp} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{DecisionProcessor}\PYG{p}{(}\PYG{n}{p}\PYG{o}{.}\PYG{n}{Configuration}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{n}{p}\PYG{o}{.}\PYG{n}{Method}\PYG{o}{.}\PYG{n}{AUTO}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Since we are dealing with a CR output, we need to propagate the coverage to the `DecisionProcessor`.}
\PYG{n}{dp}\PYG{o}{.}\PYG{n}{set\PYGZus{}coverage}\PYG{p}{(}\PYG{n}{coverage}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Train the AutoCombiner with the validation dataset}
\PYG{n}{dp}\PYG{o}{.}\PYG{n}{train}\PYG{p}{(}\PYG{n}{y\PYGZus{}ensemble\PYGZus{}valid}\PYG{p}{,} \PYG{n}{y\PYGZus{}valid}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Fuse the ensemble classification outputs (test dataset)}
\PYG{n}{y\PYGZus{}comb} \PYG{o}{=} \PYG{n}{dp}\PYG{o}{.}\PYG{n}{combine}\PYG{p}{(}\PYG{n}{y\PYGZus{}ensemble\PYGZus{}test}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The framework provides also a specific evaluation methodology for complementary\sphinxhyphen{}redundant results.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define classification performance metrics used for the evaluation}
\PYG{n}{eval\PYGZus{}metrics} \PYG{o}{=} \PYG{p}{[}
    \PYG{n}{p}\PYG{o}{.}\PYG{n}{PerformanceMetric}\PYG{o}{.}\PYG{n}{ACCURACY}\PYG{p}{,}
    \PYG{n}{p}\PYG{o}{.}\PYG{n}{PerformanceMetric}\PYG{o}{.}\PYG{n}{MICRO\PYGZus{}F1\PYGZus{}SCORE}\PYG{p}{,}
    \PYG{n}{p}\PYG{o}{.}\PYG{n}{PerformanceMetric}\PYG{o}{.}\PYG{n}{MICRO\PYGZus{}PRECISION}
\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Evaluate ensemble classifiers}
\PYG{n}{eval\PYGZus{}classifiers} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{Evaluation}\PYG{p}{(}\PYG{o}{*}\PYG{n}{eval\PYGZus{}metrics}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}classifiers}\PYG{o}{.}\PYG{n}{set\PYGZus{}instances}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ensemble}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}classifiers}\PYG{o}{.}\PYG{n}{evaluate\PYGZus{}cr\PYGZus{}decision\PYGZus{}outputs}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}ensemble\PYGZus{}test}\PYG{p}{,} \PYG{n}{coverage}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{eval\PYGZus{}classifiers}\PYG{o}{.}\PYG{n}{get\PYGZus{}report}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Evaluate the fusion}
\PYG{n}{eval\PYGZus{}combiner} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{Evaluation}\PYG{p}{(}\PYG{o}{*}\PYG{n}{eval\PYGZus{}metrics}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}combiner}\PYG{o}{.}\PYG{n}{set\PYGZus{}instances}\PYG{p}{(}\PYG{n}{dp}\PYG{o}{.}\PYG{n}{get\PYGZus{}combiner}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{eval\PYGZus{}combiner}\PYG{o}{.}\PYG{n}{evaluate\PYGZus{}cr\PYGZus{}decision\PYGZus{}outputs}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}comb}\PYG{p}{)}

\PYG{n}{dp}\PYG{o}{.}\PYG{n}{set\PYGZus{}evaluation}\PYG{p}{(}\PYG{n}{eval\PYGZus{}combiner}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dp}\PYG{o}{.}\PYG{n}{report}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
                                     accuracy  micro\PYGZus{}f1  micro\PYGZus{}precision
Ensemble                                0.804     0.804            0.804
================================= AutoCombiner \PYGZhy{} Report ==================================
                   Problem: MULTI\PYGZus{}LABEL
           Assignment type: CRISP
             Coverage type: COMPLEMENTARY\PYGZus{}REDUNDANT
   Combiner type selection: UtilityBasedCombiner, TrainableCombiner
      Compatible combiners: CRCosineSimilarity, CRMicroMajorityVoteCombiner, CRSimpleAverageCombiner, CRDecisionTemplatesCombiner, CRKNNCombiner, CRNeuralNetworkCombiner
          Optimal combiner: CRDecisionTemplatesCombiner
Classification performance:
                                     accuracy  micro\PYGZus{}f1  micro\PYGZus{}precision
AutoCombiner                            0.813     0.813            0.813
==========================================================================================
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Combiner output is always redundant, which means that all classes are covered for each sample.
To make a reasonable comparison between the combiner and the ensemble use \sphinxcode{\sphinxupquote{evaluate\_cr\_*}} methods for both.
\end{sphinxadmonition}


\chapter{License}
\label{\detokenize{license:license}}\label{\detokenize{license::doc}}
\sphinxAtStartPar
MIT License

\sphinxAtStartPar
Copyright (c) 2022 Admir Obralija, Yannick Wilhelm.
Institute for Parallel and Distributed Systems, University of Stuttgart.

\sphinxAtStartPar
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the “Software”), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

\sphinxAtStartPar
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

\sphinxAtStartPar
THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


\chapter{About}
\label{\detokenize{about:about}}\label{\detokenize{about::doc}}
\sphinxAtStartPar
This framework was developed in the context of a research project and several student works at the Institute of Parallel and Distributed Systems of the University of Stuttgart.


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{p}
\item\relax\sphinxstyleindexentry{pusion.auto.auto\_combiner}\sphinxstyleindexpageref{pusion.auto.auto_combiner:\detokenize{module-pusion.auto.auto_combiner}}
\item\relax\sphinxstyleindexentry{pusion.auto.detector}\sphinxstyleindexpageref{pusion.auto.detector:\detokenize{module-pusion.auto.detector}}
\item\relax\sphinxstyleindexentry{pusion.auto.generic\_combiner}\sphinxstyleindexpageref{pusion.auto.generic_combiner:\detokenize{module-pusion.auto.generic_combiner}}
\item\relax\sphinxstyleindexentry{pusion.control.decision\_processor}\sphinxstyleindexpageref{pusion.control.decision_processor:\detokenize{module-pusion.control.decision_processor}}
\item\relax\sphinxstyleindexentry{pusion.core.behaviour\_knowledge\_space\_combiner}\sphinxstyleindexpageref{pusion.core.behaviour_knowledge_space_combiner:\detokenize{module-pusion.core.behaviour_knowledge_space_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.borda\_count\_combiner}\sphinxstyleindexpageref{pusion.core.borda_count_combiner:\detokenize{module-pusion.core.borda_count_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.combiner}\sphinxstyleindexpageref{pusion.core.combiner:\detokenize{module-pusion.core.combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.cosine\_similarity\_combiner}\sphinxstyleindexpageref{pusion.core.cosine_similarity_combiner:\detokenize{module-pusion.core.cosine_similarity_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.decision\_templates\_combiner}\sphinxstyleindexpageref{pusion.core.decision_templates_combiner:\detokenize{module-pusion.core.decision_templates_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.dempster\_shafer\_combiner}\sphinxstyleindexpageref{pusion.core.dempster_shafer_combiner:\detokenize{module-pusion.core.dempster_shafer_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.k\_nearest\_neighbors\_combiner}\sphinxstyleindexpageref{pusion.core.k_nearest_neighbors_combiner:\detokenize{module-pusion.core.k_nearest_neighbors_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.macro\_majority\_vote\_combiner}\sphinxstyleindexpageref{pusion.core.macro_majority_vote_combiner:\detokenize{module-pusion.core.macro_majority_vote_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.maximum\_likelihood\_combiner}\sphinxstyleindexpageref{pusion.core.maximum_likelihood_combiner:\detokenize{module-pusion.core.maximum_likelihood_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.micro\_majority\_vote\_combiner}\sphinxstyleindexpageref{pusion.core.micro_majority_vote_combiner:\detokenize{module-pusion.core.micro_majority_vote_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.naive\_bayes\_combiner}\sphinxstyleindexpageref{pusion.core.naive_bayes_combiner:\detokenize{module-pusion.core.naive_bayes_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.neural\_network\_combiner}\sphinxstyleindexpageref{pusion.core.neural_network_combiner:\detokenize{module-pusion.core.neural_network_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.simple\_average\_combiner}\sphinxstyleindexpageref{pusion.core.simple_average_combiner:\detokenize{module-pusion.core.simple_average_combiner}}
\item\relax\sphinxstyleindexentry{pusion.core.weighted\_voting\_combiner}\sphinxstyleindexpageref{pusion.core.weighted_voting_combiner:\detokenize{module-pusion.core.weighted_voting_combiner}}
\item\relax\sphinxstyleindexentry{pusion.evaluation.evaluation}\sphinxstyleindexpageref{pusion.evaluation.evaluation:\detokenize{module-pusion.evaluation.evaluation}}
\item\relax\sphinxstyleindexentry{pusion.evaluation.evaluation\_metrics}\sphinxstyleindexpageref{pusion.evaluation.evaluation_metrics:\detokenize{module-pusion.evaluation.evaluation_metrics}}
\item\relax\sphinxstyleindexentry{pusion.model.configuration}\sphinxstyleindexpageref{pusion.model.configuration:\detokenize{module-pusion.model.configuration}}
\item\relax\sphinxstyleindexentry{pusion.model.report}\sphinxstyleindexpageref{pusion.model.report:\detokenize{module-pusion.model.report}}
\item\relax\sphinxstyleindexentry{pusion.util.generator}\sphinxstyleindexpageref{pusion.util.generator:\detokenize{module-pusion.util.generator}}
\item\relax\sphinxstyleindexentry{pusion.util.transformer}\sphinxstyleindexpageref{pusion.util.transformer:\detokenize{module-pusion.util.transformer}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}